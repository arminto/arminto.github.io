<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Nginx | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="article">
<meta property="og:title" content="Nginx">
<meta property="og:url" content="http://example.com/2020/10/25/Nginx/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://192.168.69.113/test.jpg">
<meta property="article:published_time" content="2020-10-25T11:11:39.000Z">
<meta property="article:modified_time" content="2021-06-05T14:45:27.261Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="web">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://192.168.69.113/test.jpg">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-Nginx" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/10/25/Nginx/" class="article-date">
  <time class="dt-published" datetime="2020-10-25T11:11:39.000Z" itemprop="datePublished">2020-10-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      Nginx
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <!--toc-->
<span id="more"></span>

<h1 id="Web网站概念"><a href="#Web网站概念" class="headerlink" title="Web网站概念"></a>Web网站概念</h1><h2 id="1-Web网站常识"><a href="#1-Web网站常识" class="headerlink" title="1. Web网站常识"></a>1. Web网站常识</h2><ol>
<li><p>域名：域名是一个IP地址的“面具” ，目的是便于记忆和访问一个或一组服务器的地址（网站，电子邮件，FTP等）。</p>
</li>
<li><p>域名解析：本地HOSTS解析、DNS服务器解析</p>
</li>
<li><p>网站的基本概念：网站、网页、主页；HTTP、URL、HTML、超链接</p>
</li>
<li><p>web网站：有web1.0（以编辑为特征）和web2.0（侧重用户交互）</p>
</li>
<li><p>动态页面与静态页面的差别, 静态页面内容几乎是固定的, 而动态页面的内容会因用户、浏览器、时间等而发生变化</p>
</li>
</ol>
<p>(img)</p>
<h2 id="2-URL的组成部分"><a href="#2-URL的组成部分" class="headerlink" title="2. URL的组成部分"></a>2. URL的组成部分</h2><h3 id="2-1-协议-Protocol"><a href="#2-1-协议-Protocol" class="headerlink" title="2.1 协议(Protocol)"></a>2.1 协议(Protocol)</h3><p><em><strong>http://</strong></em> 为协议名, 标明了请求需要使用的协议, 通常使用的就是HTTP协议 或 安全协议 HTTPS。</p>
<p>(img)</p>
<h3 id="2-2-域名-Domain"><a href="#2-2-域名-Domain" class="headerlink" title="2.2 域名(Domain)"></a>2.2 域名(Domain)</h3><p><em><strong><a target="_blank" rel="noopener" href="http://www.example.com/">www.example.com</a></strong></em> 为域名, 标明了需要请求的服务器的地址。</p>
<p>(img)</p>
<h3 id="2-3-端口-Port"><a href="#2-3-端口-Port" class="headerlink" title="2.3 端口(Port)"></a>2.3 端口(Port)</h3><p><em><strong>:80</strong></em> 是端口号, 标明了获取服务器资源的入口, 端口号用于区分服务的端口, 一台拥有公网IP的服务器可以提供许多服务, 比如Web服务、FTP服务、SMTP服务等;  服务器的资源是通过“IP地址+端口号”来区分不同的服务,  如果把服务器比作房子,  端口号就可以看做是通向不同服务的门。</p>
<p>(img)</p>
<h3 id="2-4-URL文件资源"><a href="#2-4-URL文件资源" class="headerlink" title="2.4 URL文件资源"></a>2.4 URL文件资源</h3><p><em><strong>/path/to/myfile.html</strong></em> 表示服务器上资源的路径, 过去这样的路径标记的是服务器上文件的物理路径, 但是现在路径表示的只是一个抽象地址, 并不指代任何物理地址。</p>
<p>(img)</p>
<h3 id="2-5-参数-query"><a href="#2-5-参数-query" class="headerlink" title="2.5 参数(query)"></a>2.5 参数(query)</h3><p><em><strong>?key1=value1&amp;key2=value2</strong></em> 是请求里提供的额外参数, 这些参数是以键值对的形式,通过<code>&amp;</code>符号分隔开来,服务器可以通过这些参数进行相应的个性化处理。</p>
<p>(img)</p>
<h3 id="2-6-片段-fragment"><a href="#2-6-片段-fragment" class="headerlink" title="2.6 片段(fragment)"></a>2.6 片段(fragment)</h3><p><em><strong>#SomewhereInTheDocument</strong></em> 是对资源的部分补充, <code>fragment</code>可以理解为资源内部的<code>书签</code>, 用来想服务器指明展示的内容所在的<code>书签</code>的点; 例如对于<code>HTML</code>文件来说, 浏览器会滚动到特定的或者上次浏览过的位置.对于音频或者视频资源来说,浏览器又会跳转到对应的时间节点。</p>
<p>(img)</p>
<h1 id="HTTP协议概念"><a href="#HTTP协议概念" class="headerlink" title="HTTP协议概念"></a>HTTP协议概念</h1><blockquote>
<p>HTTP是超文本传输协议，其定义了客户端与服务器端之间文本传输的规范。HTTP默认使用80端口，这个端口指的是服务端的端口，而客户端使用的端口是动态分配的。当我们没有指定端口访问时，浏览器会默认帮我们添加80端口。我们也可以自己指定访问端口如：<a href="http://www.ip.com:80。">http://www.ip.com:80。</a> </p>
<p>需要注意的是，现在大多数访问都使用了HTTPS协议，而HTTPS的默认端口为443，如果使用80端口访问HTTPS协议的服务器可能会被拒绝。</p>
</blockquote>
<h2 id="1-HTTP协议简介"><a href="#1-HTTP协议简介" class="headerlink" title="1. HTTP协议简介"></a>1. HTTP协议简介</h2><ol>
<li><p>HTTP协议的核心功能是传输Web服务器上的HTML 页面及其他文件；可以理解HTTP协议就是做业务的。</p>
</li>
<li><p>HTTP协议版本 http0.9（已过时）、==http1.0和http1.1（目前广泛使用）==、http2.0（未普及）</p>
</li>
<li><p>HTTP协议有多种获得 Web 资源的方法，最为常见的就是GET和POST及方法</p>
</li>
<li><p>HTTP请求会有很多的状态码，常看到的有：200、301、404、500等等</p>
</li>
<li><p>HTTP报文格式，一个完整的http访问包含请求（request）和响应（response）</p>
</li>
</ol>
<h2 id="2-HTTP请求的方法"><a href="#2-HTTP请求的方法" class="headerlink" title="2. HTTP请求的方法"></a>2. HTTP请求的方法</h2><blockquote>
<p>根据 HTTP 标准，HTTP 请求可以使用多种请求方法。</p>
<p>HTTP1.0 定义了三种请求方法： GET, POST 和 HEAD方法。</p>
<p>HTTP1.1 新增了六种请求方法：OPTIONS、PUT、PATCH、DELETE、TRACE 和 CONNECT 方法。</p>
</blockquote>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>GET</td>
<td>请求指定的页面信息，并返回实体主体。</td>
</tr>
<tr>
<td>HEAD</td>
<td>类似于 GET 请求，只不过返回的响应中没有具体的内容，用于获取报头</td>
</tr>
<tr>
<td>POST</td>
<td>向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST 请求可能会导致新的资源的建立和/或已有资源的修改。</td>
</tr>
<tr>
<td>PUT</td>
<td>从客户端向服务器传送的数据取代指定的文档的内容。</td>
</tr>
<tr>
<td>DELETE</td>
<td>请求服务器删除指定的页面。</td>
</tr>
<tr>
<td>CONNECT</td>
<td>HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器。</td>
</tr>
<tr>
<td>OPTIONS</td>
<td>允许客户端查看服务器的性能。</td>
</tr>
<tr>
<td>TRACE</td>
<td>回显服务器收到的请求，主要用于测试或诊断。</td>
</tr>
<tr>
<td>PATCH</td>
<td>是对 PUT 方法的补充，用来对已知资源进行局部更新 。</td>
</tr>
</tbody></table>
<h2 id="3-HTTP响应头信息"><a href="#3-HTTP响应头信息" class="headerlink" title="3. HTTP响应头信息"></a>3. HTTP响应头信息</h2><table>
<thead>
<tr>
<th>应答头</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Allow</td>
<td>服务器支持哪些请求方法（如GET、POST等）。</td>
</tr>
<tr>
<td>Content-Encoding</td>
<td>文档的编码（Encode）方法。只有在解码之后才可以得到Content-Type头指定的内容类型。利用gzip压缩文档能够显著地减少HTML文档的下载时间。Java的GZIPOutputStream可以很方便地进行gzip压缩，但只有Unix上的Netscape和Windows上的IE 4、IE  5才支持它。因此，Servlet应该通过查看Accept-Encoding头（即request.getHeader(“Accept-Encoding”)）检查浏览器是否支持gzip，为支持gzip的浏览器返回经gzip压缩的HTML页面，为其他浏览器返回普通页面。</td>
</tr>
<tr>
<td>Content-Length</td>
<td>表示内容长度。只有当浏览器使用持久HTTP连接时才需要这个数据。如果你想要利用持久连接的优势，可以把输出文档写入  ByteArrayOutputStream，完成后查看其大小，然后把该值放入Content-Length头，最后通过byteArrayStream.writeTo(response.getOutputStream()发送内容。</td>
</tr>
<tr>
<td>Content-Type</td>
<td>表示后面的文档属于什么MIME类型。Servlet默认为text/plain，但通常需要显式地指定为text/html。由于经常要设置Content-Type，因此HttpServletResponse提供了一个专用的方法setContentType。</td>
</tr>
<tr>
<td>Date</td>
<td>当前的GMT时间。你可以用setDateHeader来设置这个头以避免转换时间格式的麻烦。</td>
</tr>
<tr>
<td>Expires</td>
<td>应该在什么时候认为文档已经过期，从而不再缓存它？</td>
</tr>
<tr>
<td>Last-Modified</td>
<td>文档的最后改动时间。客户可以通过If-Modified-Since请求头提供一个日期，该请求将被视为一个条件GET，只有改动时间迟于指定时间的文档才会返回，否则返回一个304（Not Modified）状态。Last-Modified也可用setDateHeader方法来设置。</td>
</tr>
<tr>
<td>Location</td>
<td>表示客户应当到哪里去提取文档。Location通常不是直接设置的，而是通过HttpServletResponse的sendRedirect方法，该方法同时设置状态代码为302。</td>
</tr>
<tr>
<td>Refresh</td>
<td>表示浏览器应该在多少时间之后刷新文档，以秒计。除了刷新当前文档之外，你还可以通过setHeader(“Refresh”, “5; URL=<a target="_blank" rel="noopener" href="http://host/path&quot;)%E8%AE%A9%E6%B5%8F%E8%A7%88%E5%99%A8%E8%AF%BB%E5%8F%96%E6%8C%87%E5%AE%9A%E7%9A%84%E9%A1%B5%E9%9D%A2%E3%80%82">http://host/path&quot;)让浏览器读取指定的页面。</a>  注意这种功能通常是通过设置HTML页面HEAD区的＜META HTTP-EQUIV=”Refresh”  CONTENT=”5;URL=<a target="_blank" rel="noopener" href="http://host/path&quot;%EF%BC%9E%E5%AE%9E%E7%8E%B0%EF%BC%8C%E8%BF%99%E6%98%AF%E5%9B%A0%E4%B8%BA%EF%BC%8C%E8%87%AA%E5%8A%A8%E5%88%B7%E6%96%B0%E6%88%96%E9%87%8D%E5%AE%9A%E5%90%91%E5%AF%B9%E4%BA%8E%E9%82%A3%E4%BA%9B%E4%B8%8D%E8%83%BD%E4%BD%BF%E7%94%A8CGI%E6%88%96Servlet%E7%9A%84HTML%E7%BC%96%E5%86%99%E8%80%85%E5%8D%81%E5%88%86%E9%87%8D%E8%A6%81%E3%80%82%E4%BD%86%E6%98%AF%EF%BC%8C%E5%AF%B9%E4%BA%8EServlet%E6%9D%A5%E8%AF%B4%EF%BC%8C%E7%9B%B4%E6%8E%A5%E8%AE%BE%E7%BD%AERefresh%E5%A4%B4%E6%9B%B4%E5%8A%A0%E6%96%B9%E4%BE%BF%E3%80%82">http://host/path&quot;＞实现，这是因为，自动刷新或重定向对于那些不能使用CGI或Servlet的HTML编写者十分重要。但是，对于Servlet来说，直接设置Refresh头更加方便。</a>   注意Refresh的意义是”N秒之后刷新本页面或访问指定页面”，而不是”每隔N秒刷新本页面或访问指定页面”。因此，连续刷新要求每次都发送一个Refresh头，而发送204状态代码则可以阻止浏览器继续刷新，不管是使用Refresh头还是＜META HTTP-EQUIV=”Refresh” …＞。   注意Refresh头不属于HTTP 1.1正式规范的一部分，而是一个扩展，但Netscape和IE都支持它。</td>
</tr>
<tr>
<td>Server</td>
<td>服务器名字。Servlet一般不设置这个值，而是由Web服务器自己设置。</td>
</tr>
<tr>
<td>Set-Cookie</td>
<td>设置和页面关联的Cookie。Servlet不应使用response.setHeader(“Set-Cookie”, …)，而是应使用HttpServletResponse提供的专用方法addCookie。参见下文有关Cookie设置的讨论。</td>
</tr>
<tr>
<td>WWW-Authenticate</td>
<td>客户应该在Authorization头中提供什么类型的授权信息？在包含401（Unauthorized）状态行的应答中这个头是必需的。例如，response.setHeader(“WWW-Authenticate”, “BASIC realm=＼”executives＼””)。  注意Servlet一般不进行这方面的处理，而是让Web服务器的专门机制来控制受密码保护页面的访问（例如.htaccess）。</td>
</tr>
</tbody></table>
<h2 id="4-HTTP状态代码"><a href="#4-HTTP状态代码" class="headerlink" title="4. HTTP状态代码"></a>4. HTTP状态代码</h2><blockquote>
<p>HTTP状态码的英文为HTTP Status Code。</p>
<p>HTTP状态码由三个十进制数字组成，第一个十进制数字定义了状态码的类型，后两个数字没有分类的作用。HTTP状态码共分为5种类型：1xx   2xx   3xx   4xx   5xx 。</p>
<p>当用户访问一个网页时，浏览器会向网页所在服务器发出请求，当浏览器接收并显示网页前，此网页所在的服务器会返回一个包含HTTP状态码的信息头（server header）用以响应浏览器的请求。</p>
</blockquote>
<p><strong>下面是最常见的HTTP状态码：</strong></p>
<blockquote>
<p>200        服务器成功返回内容</p>
<p>301/2     永久/临时重定向</p>
<p>304        未修改 Not Modified</p>
<p>307        重定向中保留原始数据</p>
<p>404        请求的页面不存在</p>
<p>413        请求实体太大，服务器拒绝处理当前请求</p>
<p>500        服务器内部错误</p>
<p>502        代理请求后端失败</p>
<p>503        服务器暂时不可用</p>
<p>504        请求成功，但是连接超时</p>
</blockquote>
<p>(img)</p>
<p><strong>[其他的一些HTTP状态码]</strong></p>
<h2 id="5-HTTP-content-type"><a href="#5-HTTP-content-type" class="headerlink" title="5. HTTP  content-type"></a>5. HTTP  content-type</h2><p><strong>简介</strong></p>
<blockquote>
<p>Content-Type（内容类型），一般是指网页中存在的 Content-Type，用于定义网络文件的类型和网页的编码，决定浏览器将以什么形式、什么编码读取这个文件，这就是经常看到一些 PHP 网页点击的结果却是下载一个文件或一张图片的原因。</p>
<p>Content-Type 标头告诉客户端实际返回的内容的内容类型。</p>
</blockquote>
<p><strong>语法</strong></p>
<p>Content-Type: text/html; charset=utf-8<br>Content-Type: multipart/form-data; boundary=something</p>
<p><strong>实例</strong></p>
<p>(img)</p>
<p><strong>常见的媒体格式类型如下</strong></p>
<ul>
<li>text/html ： HTML格式</li>
<li>text/plain ：纯文本格式</li>
<li>text/xml ： XML格式</li>
<li>image/gif ：gif图片格式</li>
<li>image/jpeg ：jpg图片格式</li>
<li>image/png：png图片格式</li>
</ul>
<p><strong>以application开头的媒体格式类型</strong></p>
<ul>
<li>application/xhtml+xml ：XHTML格式</li>
<li>application/xml： XML数据格式</li>
<li>application/atom+xml ：Atom XML聚合格式</li>
<li>application/json： JSON数据格式</li>
<li>application/pdf：pdf格式</li>
<li>application/msword ： Word文档格式</li>
<li>application/octet-stream ： 二进制流数据（如常见的文件下载）</li>
</ul>
<p><strong>常见的媒体格式是上传文件之时使用的</strong></p>
<ul>
<li>multipart/form-data ： 需要在表单中进行文件上传时，就需要使用该格式</li>
</ul>
<p><strong>[更加详细的HTTP  content-type 对照表]</strong></p>
<h1 id="Nginx原理介绍"><a href="#Nginx原理介绍" class="headerlink" title="Nginx原理介绍"></a>Nginx原理介绍</h1><h2 id="1-1-Nginx-概述"><a href="#1-1-Nginx-概述" class="headerlink" title="1.1 Nginx 概述"></a>1.1 Nginx 概述</h2><blockquote>
<p>Nginx是⼀一个开源且⾼高性能、可靠的HTTP中间件、代理理服务。</p>
<p>开源: 直接获取源代码</p>
<p>⾼高性能: 支持海海量量并发</p>
</blockquote>
<p>(img)</p>
<h2 id="1-2-Nginx的优缺点"><a href="#1-2-Nginx的优缺点" class="headerlink" title="1.2 Nginx的优缺点"></a>1.2 Nginx的优缺点</h2><ul>
<li><p>==<strong>优点</strong>==</p>
<ul>
<li><strong>高并发量</strong><ul>
<li>根据官方给出的数据，能够支持高达 50000 个[并发连接数]的响应。</li>
</ul>
</li>
<li><strong>内存消耗少</strong><ul>
<li>处理静态文件，同样起web 服务，比apache 占用更少的内存及资源，所以它是轻量级的。</li>
</ul>
</li>
<li><strong>简单稳定</strong><ul>
<li>配置简单，基本在一个conf文件中配置，性能比较稳定，可以7*24小时长时间不间断运行。</li>
</ul>
</li>
<li><strong>支持Rwrite重写规则</strong><ul>
<li>能够根据域名、URL的不同， 将HTTP请求分发到不同的后端服务器群组。</li>
</ul>
</li>
<li><strong>功能多，低成本</strong><ul>
<li>Nginx可以做高并发的负载均衡，且Nginx是开源免费的，如果使用F5等硬件来做负载均衡，硬件成本比较高。</li>
</ul>
</li>
</ul>
</li>
<li><p>==<strong>缺点</strong>==</p>
<ul>
<li><strong>动态处理差</strong><ul>
<li>Nginx处理静态文件好，耗费内存少，但是处理动态页面则很鸡肋</li>
</ul>
</li>
<li><strong>rewrite弱</strong><ul>
<li>虽然Nginx支持rewrite功能，但是相比于Apache来说，Apache比nginx 的rewrite 要强大。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="1-3-Nginx应用场景"><a href="#1-3-Nginx应用场景" class="headerlink" title="1.3 Nginx应用场景"></a>1.3 Nginx应用场景</h2><blockquote>
<p>静态处理</p>
<p>反向代理</p>
<p>负载均衡</p>
<p>资源缓存</p>
<p>安全防护</p>
<p>访问限制</p>
<p>访问认证</p>
</blockquote>
<h2 id="1-4-Nginx的进程模型"><a href="#1-4-Nginx的进程模型" class="headerlink" title="1.4 Nginx的进程模型"></a>1.4 Nginx的进程模型</h2><blockquote>
<p>==<strong>Nginx的启动方式有两种：</strong>==</p>
</blockquote>
<ul>
<li><p><strong>单进程启动：</strong></p>
<ul>
<li>此时系统中只有一个进程，这个进程既是master进程，也是worker进程。</li>
</ul>
</li>
<li><p><strong>多进程启动：</strong></p>
<ul>
<li>此时系统中有且仅有一个master进程，有多个worker进程，master进程主要是用来管理worker进程的。</li>
</ul>
</li>
</ul>
<blockquote>
<p>==<strong>Nginx有两种进程：</strong>==</p>
</blockquote>
<p><strong>Master主进程：</strong></p>
<ol>
<li>接收客户端的请求，然后在将客户端的请求交给他下面的子进程，子进程返回处理结果后，再将处理结果返回给客户端</li>
<li>监控并管理子进程的运行状态，当子进程出现异常情况下退出后，自动生成新的子进程</li>
</ol>
<p><strong>Worker子进程：</strong></p>
<ol>
<li>将主进程的请求交给内核去处理，然后在继续接收主进程发来的请求，当内核处理完后，返回给子进程处理结果，然后子进程再将结果返回给主进程。</li>
<li>Nginx子进程的数量一般我们会设置与当前服务器的CPU核心数一致，可以使用<code>auto</code>指令让Nginx跟进系统自动设置worker</li>
</ol>
<p>[(img)]</p>
<h2 id="1-5-Nginx的组成逻辑图"><a href="#1-5-Nginx的组成逻辑图" class="headerlink" title="1.5 Nginx的组成逻辑图"></a>1.5 Nginx的组成逻辑图</h2><p>(img)</p>
<h2 id="1-6-Nginx的模块是什么"><a href="#1-6-Nginx的模块是什么" class="headerlink" title="1.6 Nginx的模块是什么"></a>1.6 Nginx的模块是什么</h2><blockquote>
<p>Nginx之所以有如此多的特性和功能，就是因为有大量的第三方开发者为其开发第三方模块</p>
</blockquote>
<p>(img)</p>
<p>==上图中都可以在[nginx官方文档]中查询，这里就不再叙述了~~==</p>
<h1 id="Nginx应用部署"><a href="#Nginx应用部署" class="headerlink" title="Nginx应用部署"></a>Nginx应用部署</h1><h2 id="1-1-进入-nginx-官网，下载"><a href="#1-1-进入-nginx-官网，下载" class="headerlink" title="1.1 进入 nginx 官网，下载"></a>1.1 进入 nginx 官网，下载</h2><blockquote>
<p><strong>Nginx官方网站：<a target="_blank" rel="noopener" href="http://nginx.org/">http://nginx.org/</a></strong></p>
</blockquote>
<p>(img)</p>
<h2 id="1-2-安装Nginx依赖"><a href="#1-2-安装Nginx依赖" class="headerlink" title="1.2 安装Nginx依赖"></a>1.2 安装Nginx依赖</h2><blockquote>
<p><strong>安装 openssl、zlib</strong></p>
</blockquote>
<p>yum -y install make zlib zlib-devel gcc gcc-c++ libtool openssl openssl-devel pcre pcre-devel</p>
<h2 id="1-3-安装Nginx并修改属主属祖"><a href="#1-3-安装Nginx并修改属主属祖" class="headerlink" title="1.3 安装Nginx并修改属主属祖"></a>1.3 安装Nginx并修改属主属祖</h2><p>#解压<br>tar xf nginx-1.12.2.tar.gz -C /usr/src/ &amp;&amp; cd /usr/src/nginx-1.12.2/</p>
<p>#配置、编译、安装<br>./configure –prefix=/usr/local/nginx –user=nginx –group=nginx –with-http_ssl_module –with-http_stub_status_module –with-threads –with-file-aio –with-http_sub_module –with-http_dav_module –with-http_flv_module –with-mail –with-mail_ssl_module –with-stream –with-stream_ssl_module –with-stream_realip_module &amp;&amp; make &amp;&amp; make install &amp;&amp; cd</p>
<p>#修改属主属组<br>useradd -s /sbin/nologin -M nginx<br>chown -R nginx:nginx /usr/local/nginx/</p>
<blockquote>
<p><strong>编译参数解释：</strong></p>
</blockquote>
<h1 id="这三个模块是用来做四层负载转发的"><a href="#这三个模块是用来做四层负载转发的" class="headerlink" title="这三个模块是用来做四层负载转发的"></a>这三个模块是用来做四层负载转发的</h1><p>–with-stream<br>–with-stream_ssl_module<br>–with-stream_realip_module</p>
<p>#指定安装位置<br>–prefix=/usr/local/nginx</p>
<p>#指定worker进程运行的用户和组<br>–user=nginx –group=nginx           </p>
<p>#开启状态监听模块<br>–with-http_stub_status_module</p>
<p>#指向配置文件存放位置<br>–conf-path=/xxx/xxx/</p>
<p>#指向错误日志存放位置<br>–error-log-path=/xxx/xxx/</p>
<p>#指向pid文件存放位置<br>–pid-path=/xxx/xxx/</p>
<p>#启用rtsig模块支持（实时信号）<br>–with-rtsig_module</p>
<h1 id="临时缓存⽂文件"><a href="#临时缓存⽂文件" class="headerlink" title="临时缓存⽂文件"></a>临时缓存⽂文件</h1><p>–http-client-body-temp-path=/xxx/xxx/client_tem<br>–http-proxy-temp-path=/xxx/xxx/proxy_temp<br>–http-fastcgi-temp-path=/xxx/xxx/fastcgi_temp<br>–http-uwsgi-temp-path=/xxx/xxx/uwsgi_temp<br>–http-scgi-temp-path=/xxx/xxx/scgi_temp</p>
<p>#添加模块<br>–add-module=/xxx/xxx/</p>
<p>#启用select模块支持（一种轮询模式,不推荐在高载环境下使用）禁用：–without-select_module<br>–with-select_module</p>
<p>#启用ngx_http_ssl_module支持(使支持https请求，需已安装openssl)<br>–with-http_ssl_module</p>
<p>#启用ngx_http_xslt_module支持（过滤转换XML请求）<br>–with-http_xslt_module</p>
<p>#启用ngx_http_image_filter_module支持（传输JPEG/GIF/PNG 图片的一个过滤器）（默认为不启用，要用到gd库）<br>–with-http_image_filter_module</p>
<p>#启用ngx_http_gzip_static_module支持（在线实时压缩输出数据流）<br>–with-http_gzip_static_module</p>
<p>#启用ngx_http_degradation_module支持（允许在内存不足的情况下返回204或444码）<br>–with-http_degradation_module</p>
<p>#禁用ngx_http_access_module支持（该模块提供了一个简单的基于主机的访问控制，允许或拒绝基于ip地址）<br>–without-http_access_module</p>
<p>#禁用ngx_http_auth_basic_module（该模块是可以使用用户名和密码基于http基本认证方法，来保护你的站点或其部分内容）<br>–without-http_auth_basic_module</p>
<p>#禁用ngx_http_rewrite_module支持（该模块允许使用正则表达式改变URL）<br>–without-http_rewrite_module</p>
<p>#禁用ngx_http_fastcgi_module支持（该模块允许Nginx 与FastCGI 进程交互，并通过传递参数来控制FastCGI 进程工作。）<br>–without-http_fastcgi_module</p>
<h2 id="1-4-设置防火墙规则"><a href="#1-4-设置防火墙规则" class="headerlink" title="1.4 设置防火墙规则"></a>1.4 设置防火墙规则</h2><blockquote>
<p><strong>开放80端口号</strong></p>
</blockquote>
<p>查看开放的端口号<br>firewall-cmd –list-all</p>
<p>设置开放的端口号<br>firewall-cmd –add-service=http -permanent<br>sudo firewall-cmd –add-port=80/tcp -permanent</p>
<p>重启防火墙<br>firewall-cmd -reload</p>
<h2 id="1-5-Nginx常用命令-及-信号"><a href="#1-5-Nginx常用命令-及-信号" class="headerlink" title="1.5 Nginx常用命令 及 信号"></a>1.5 Nginx常用命令 及 信号</h2><blockquote>
<p><strong>命令</strong></p>
</blockquote>
<p>(img)</p>
<blockquote>
<p><strong>信号</strong></p>
</blockquote>
<p>(img)</p>
<p><strong>信号详解：</strong></p>
<p>1、TERM，INT：nginx的主进程马上被关闭，不能完整处理正在使用的nginx的用户的请求，等同于 nginx -s stop。</p>
<p>2、QUIT：优雅的关闭nginx进程，在处理完所有正在使用nginx用户请求后再关闭nginx进程，等同于nginx -s quit。</p>
<p>3、HUP： nginx主进程不变，nginx进程不关闭，但是重新加载配置文件。等同于nginx -s reload。</p>
<p>4、USR1：不用关闭nginx进程就可以重读日志，此命令可以用于nginx的日志定时备份，按月/日等时间间隔分割有用。</p>
<p>5、USR2：nginx的版本需要升级的时候，不需要停止nginx，就能对nginx升级。</p>
<p>6、WINCH：配合USR2对nginx升级，优雅的关闭nginx旧版本的进程，</p>
<blockquote>
<p>reload重载配置文件的过程</p>
</blockquote>
<p>(img)</p>
<p>(img)</p>
<h2 id="1-6-优化Nginx且编写启动脚本"><a href="#1-6-优化Nginx且编写启动脚本" class="headerlink" title="1.6 优化Nginx且编写启动脚本"></a>1.6 优化Nginx且编写启动脚本</h2><blockquote>
<p><strong>两者做一个就行，当然也可以都做</strong></p>
</blockquote>
<h1 id="Nginx软连接"><a href="#Nginx软连接" class="headerlink" title="Nginx软连接"></a>Nginx软连接</h1><p>ln -s /usr/local/nginx/sbin/* /usr/local/bin/</p>
<h1 id="Nginx启动脚本"><a href="#Nginx启动脚本" class="headerlink" title="Nginx启动脚本"></a>Nginx启动脚本</h1><p>cat &lt;<EOF> /lib/systemd/system/nginx.service<br><a href="%E6%9C%8D%E5%8A%A1%E7%9A%84%E8%AF%B4%E6%98%8E">Unit</a><br>Description=nginx<br>After=network.target</p>
<p>[Service]<br>Type=forking<br>ExecStart=/usr/local/nginx/sbin/nginx<br>ExecReload=/usr/local/nginx/sbin/nginx -s reload<br>ExecStop=/usr/local/nginx/sbin/nginx -s quit<br>PrivateTmp=true</p>
<p>[Install]<br>WantedBy=multi-user.target<br>EOF</p>
<h1 id="给予启动脚本执行权限"><a href="#给予启动脚本执行权限" class="headerlink" title="给予启动脚本执行权限"></a>给予启动脚本执行权限</h1><p>chmod u+x /lib/systemd/system/nginx.service</p>
<h1 id="上述脚本解释"><a href="#上述脚本解释" class="headerlink" title="上述脚本解释"></a>上述脚本解释</h1><p>Description:描述服务<br>After:描述服务类别<br>[Service]服务运行参数的设置，注意：[Service]的启动、重启、停止命令全部要求使用绝对路径<br>Type=forking是后台运行的形式<br>ExecStart为服务的具体运行命令<br>ExecReload为重启命令<br>ExecStop为停止命令<br>PrivateTmp=True表示给服务分配独立的临时空间<br>[Install]运行级别下服务安装的相关设置，可设置为多用户，即系统运行级别为3</p>
<h2 id="1-7-启动Nginx服务"><a href="#1-7-启动Nginx服务" class="headerlink" title="1.7 启动Nginx服务"></a>1.7 启动Nginx服务</h2><h1 id="删除nginx-conf配置文件所有的注释行和空行（这步可有可无）"><a href="#删除nginx-conf配置文件所有的注释行和空行（这步可有可无）" class="headerlink" title="删除nginx.conf配置文件所有的注释行和空行（这步可有可无）"></a>删除nginx.conf配置文件所有的注释行和空行（这步可有可无）</h1><p>sed -i /#.*/d /usr/local/nginx/conf/nginx.conf<br>sed -i /^$/d /usr/local/nginx/conf/nginx.conf</p>
<h1 id="启动nginx"><a href="#启动nginx" class="headerlink" title="启动nginx"></a>启动nginx</h1><p>systemctl start nginx<br>systemctl enable nginx</p>
<h1 id="查看状态"><a href="#查看状态" class="headerlink" title="查看状态"></a>查看状态</h1><p>netstat -anptu|grep “nginx”<br>#####################################################################################################<br>tcp        0      0 0.0.0.0:80              0.0.0.0:*               LISTEN      4827/nginx: master<br>#####################################################################################################</p>
<p>ps -aux|grep “nginx”<br>#####################################################################################################<br>root 4827  0.0  0.1  46108  1152 ?  Ss  21:56   0:00 nginx: master process /usr/local/nginx/sbin/nginx<br>nginx      4830  0.0  0.1  46556  1936 ?        S    21:56   0:00 nginx: worker process<br>root       4849  0.0  0.0 112676   980 pts/0    R+   21:57   0:00 grep –color=auto nginx<br>#####################################################################################################</p>
<h1 id="查看安装Nginx时的编译参数和版本"><a href="#查看安装Nginx时的编译参数和版本" class="headerlink" title="查看安装Nginx时的编译参数和版本"></a>查看安装Nginx时的编译参数和版本</h1><p>nginx -V<br>#####################################################################################################<br>nginx version: nginx/1.12.2<br>built by gcc 4.8.5 20150623 (Red Hat 4.8.5-39) (GCC)<br>built with OpenSSL 1.0.2k-fips  26 Jan 2017<br>TLS SNI support enabled<br>configure arguments: –prefix=/usr/local/nginx –user=nginx –group=nginx –with-http_ssl_module –with-http_stub_status_module –with-threads –with-file-aio –with-http_sub_module –with-http_dav_module –with-http_flv_module –with-mail –with-mail_ssl_module –with-stream –with-stream_ssl_module –with-stream_realip_module<br>#####################################################################################################</p>
<h1 id="Nginx常用模块及内置变量"><a href="#Nginx常用模块及内置变量" class="headerlink" title="Nginx常用模块及内置变量"></a>Nginx常用模块及内置变量</h1><h2 id="1-1-Nginx常用模块"><a href="#1-1-Nginx常用模块" class="headerlink" title="1.1 Nginx常用模块"></a>1.1 Nginx常用模块</h2><blockquote>
<p><strong>Nginx模块分为 Nginx官方模块 以及 Nginx第三方模块</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th>Nginx编译选项</th>
<th>模块作用</th>
</tr>
</thead>
<tbody><tr>
<td>ngx_http_core_module</td>
<td>包含⼀些核心的http参数配置，对应Nginx的配置区块部分</td>
</tr>
<tr>
<td>ngx_http_access_module</td>
<td>访问控制模块，用来控制网站用户对Nginx的访问</td>
</tr>
<tr>
<td>ngx_http_gzip_module</td>
<td>压缩模块，对Nginx返回的数据压缩，属于性能优化模块</td>
</tr>
<tr>
<td>ngx_http_fastcgi_module</td>
<td>fastci模块，和动态应用相关的模块，例如PHP</td>
</tr>
<tr>
<td>ngx_http_proxy_module</td>
<td>proxy代理模块</td>
</tr>
<tr>
<td>ngx_http_upstream_module</td>
<td>负载均衡模块，可以实现网站的负载均衡功能及节点的健康检查。</td>
</tr>
<tr>
<td>ngx_http_rewrite_module</td>
<td>URL地址重写模块</td>
</tr>
<tr>
<td>ngx_http_limit_conn_module</td>
<td>限制用户并发连接数及请求数模块</td>
</tr>
<tr>
<td>ngx_http_limit_req_module</td>
<td>限制Nginx request processing rate根据定义的key</td>
</tr>
<tr>
<td>ngx_http_log_module</td>
<td>访问日志模块，以指定的格式记录Nginx客户访问日志等信息</td>
</tr>
<tr>
<td>ngx_http_auth_basic_module</td>
<td>Web认证模块，设置Web用户通过账号密码访问Nginx</td>
</tr>
<tr>
<td>nginx_http_ssl_module</td>
<td>ssl模块，用于加密的http连接，如https</td>
</tr>
</tbody></table>
<h2 id="1-2-Nginx内置变量"><a href="#1-2-Nginx内置变量" class="headerlink" title="1.2 Nginx内置变量"></a>1.2 Nginx内置变量</h2><blockquote>
<p><strong>http请求变量</strong></p>
<p><strong>Nginx内置变量</strong></p>
<p><strong>自定义变量</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th>变量名</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>$uri</td>
<td>当前请求的uri，不带参数</td>
</tr>
<tr>
<td>$request_uri</td>
<td>请求的uri，带完整参数</td>
</tr>
<tr>
<td>$host</td>
<td>http请求报文中host首部,如果没有则以处理此请求的虚拟主机的主机名代替</td>
</tr>
<tr>
<td>$hostname</td>
<td>nginx服务运行在主机的主机名</td>
</tr>
<tr>
<td>$remote_addr</td>
<td>客户端IP</td>
</tr>
<tr>
<td>$remote_port</td>
<td>客户端口</td>
</tr>
<tr>
<td>$remote_user</td>
<td>用户认证时客户端用户输入的用户名</td>
</tr>
<tr>
<td>$request_filename</td>
<td>用户请求中的URI经过本地root或alias转换后映射的本地文件路径</td>
</tr>
<tr>
<td>$request_method</td>
<td>请求方法, GET POST PUT</td>
</tr>
<tr>
<td>$server_addr</td>
<td>服务器地址</td>
</tr>
<tr>
<td>$server_port</td>
<td>服务器端口</td>
</tr>
<tr>
<td>$server_name</td>
<td>服务器名称</td>
</tr>
<tr>
<td>$server_protocol</td>
<td>服务器向客户端发送响应时的协议, 如http/1.1 http/1.0</td>
</tr>
<tr>
<td>$scheme</td>
<td>在请求中使用scheme, 如<a target="_blank" rel="noopener" href="http://xxx.com中的http/">http://xxx.com中的http</a></td>
</tr>
<tr>
<td>$http_HEADER</td>
<td>匹配请求报文中指定的HEADER</td>
</tr>
<tr>
<td>$http_host</td>
<td>匹配请求报文中的host首部</td>
</tr>
<tr>
<td>$document_root</td>
<td>当前请求映射到的root配置</td>
</tr>
</tbody></table>
<h1 id="Nginx-conf-配置文件"><a href="#Nginx-conf-配置文件" class="headerlink" title="[Nginx.conf 配置文件]"></a>[Nginx.conf 配置文件]</h1><h2 id="1-1-Nginx配置文件语法"><a href="#1-1-Nginx配置文件语法" class="headerlink" title="1.1 Nginx配置文件语法"></a>1.1 Nginx配置文件语法</h2><p>(img)</p>
<h2 id="1-2-配置文件整体结构"><a href="#1-2-配置文件整体结构" class="headerlink" title="1.2 配置文件整体结构"></a>1.2 配置文件整体结构</h2><p>==<strong>Nginx主配置文件 nginx.conf，整个配置文件是以区块的形式组织的；一般，每个区块以一对大括号 {} 来表示开始与结束。</strong>==</p>
<blockquote>
<ol>
<li><p>Main位于nginx.conf配置文件的最高层；Main层下可以有Event、HTTP层</p>
</li>
<li><p>HTTP层下面允许有多个Server层, 用于对不同的网站做不同的配置</p>
</li>
<li><p>Server层也允许有多个location, 用于对不同的路径资源进行不同模块的配置</p>
</li>
</ol>
</blockquote>
<p>[(img)]</p>
<h3 id="1-2-1-main全局块"><a href="#1-2-1-main全局块" class="headerlink" title="1.2.1 main全局块"></a>1.2.1 main全局块</h3><p>配置影响nginx全局的指令。主要包括：</p>
<ul>
<li>配置运行Nginx服务器用户（组）</li>
<li>worker process数</li>
<li>Nginx进程</li>
<li>PID存放路径错误日志的存放路径</li>
<li>配置文件的引入</li>
</ul>
<h3 id="1-2-2-events块"><a href="#1-2-2-events块" class="headerlink" title="1.2.2 events块"></a>1.2.2 events块</h3><p>配置影响nginx服务器或与用户的网络连接。主要包括：</p>
<ul>
<li>设置网络连接的序列化</li>
<li>是否允许同时接收多个网络连接</li>
<li>事件驱动模型的选择</li>
<li>最大连接数的配置</li>
</ul>
<h3 id="1-2-3-http块"><a href="#1-2-3-http块" class="headerlink" title="1.2.3 http块"></a>1.2.3 http块</h3><p>可以嵌套多个server，配置代理，缓存，日志定义等绝大多数功能和第三方模块的配置。主要包括：</p>
<ul>
<li>定义MIMI-Type</li>
<li>自定义服务日志</li>
<li>允许sendfile方式传输文件</li>
<li>连接超时时间</li>
<li>单连接请求数上限</li>
</ul>
<h3 id="1-2-4-server块"><a href="#1-2-4-server块" class="headerlink" title="1.2.4 server块"></a>1.2.4 server块</h3><p>配置虚拟主机的相关参数，一个http中可以有多个server。主要包括：</p>
<ul>
<li>配置网络监听</li>
<li>基于名称的虚拟主机配置</li>
<li>基于IP的虚拟主机配置</li>
</ul>
<h3 id="1-2-5-location块"><a href="#1-2-5-location块" class="headerlink" title="1.2.5 location块"></a>1.2.5 location块</h3><p>配置请求的路由，以及各种页面的处理情况。主要包括：</p>
<ul>
<li>location配置</li>
<li>请求根目录配置更改</li>
<li>location的URI</li>
<li>网站默认首页配置</li>
</ul>
<h2 id="1-3-Nginx的默认配置"><a href="#1-3-Nginx的默认配置" class="headerlink" title="1.3 Nginx的默认配置"></a>1.3 Nginx的默认配置</h2><h4 id="main全局块"><a href="#main全局块" class="headerlink" title="main全局块"></a>main全局块</h4><p>worker_processes  1;                           // nginx的worker工作进程，一般数值为cpu核数</p>
<h4 id="events事件块"><a href="#events事件块" class="headerlink" title="events事件块"></a>events事件块</h4><p>events {<br>    worker_connections  1024;                  // 每个后台worker process进程的最大并发连接数<br>}</p>
<h4 id="http块"><a href="#http块" class="headerlink" title="http块"></a>http块</h4><p>http {<br>    include       mime.types;                  // 文件扩展名与类型映射表<br>    default_type  application/octet-stream;    // 默认文件类型<br>    sendfile        on;                        // 开启高效传输模式，默认为off<br>    keepalive_timeout  65;                     // 连接超时时间，单位是秒</p>
<pre><code>#### server块 ####
server &#123;
    listen       80;                       // 监听端口
    server_name  localhost;                // 提供服务的域名或主机名
    
    #### location块 ####
    location / &#123;
        root   html;                       // 存放网站路径
        index  index.html index.htm;       // 默认访问首⻚文件
    &#125;
    // 指定错误代码, 统一定义错误页面, 错误代码重定向到新的 Locaiton资源上
    error_page   500 502 503 504  /50x.html;
    location = /50x.html &#123;
        root   html;
    &#125;
&#125;
</code></pre>
<p>}</p>
<h1 id="Nginx日志文件详解"><a href="#Nginx日志文件详解" class="headerlink" title="Nginx日志文件详解"></a>Nginx日志文件详解</h1><h2 id="1-1-Nginx日志配置"><a href="#1-1-Nginx日志配置" class="headerlink" title="1.1 Nginx日志配置"></a>1.1 Nginx日志配置</h2><blockquote>
<p><strong>在学习日志之前, 我们需要先了解下HTTP请求和返回</strong></p>
</blockquote>
<p>curl -v <a target="_blank" rel="noopener" href="https://www.baidu.com/">https://www.baidu.com</a></p>
<p>(img)</p>
<p>==<strong>log_format语法格式及参数语法说明如下:</strong>==</p>
<h3 id="配置语法-包括-error-log-access-log"><a href="#配置语法-包括-error-log-access-log" class="headerlink" title="配置语法: 包括: error.log access.log"></a>配置语法: 包括: error.log access.log</h3><p>Syntax: log_format  <NAME>  <String>;<br>Default: log_format combined “…”;<br>Context: http</p>
<h3 id="Nginx默认日志格式"><a href="#Nginx默认日志格式" class="headerlink" title="Nginx默认日志格式"></a>Nginx默认日志格式</h3><p>log_format  main  ‘$remote_addr - $remote_user [$time_local] “$request” ‘<br>                  ‘$status $body_bytes_sent “$http_referer” ‘<br>                  ‘“$http_user_agent” “$http_x_forwarded_for”‘;</p>
<h3 id="Nginx日志变量解释"><a href="#Nginx日志变量解释" class="headerlink" title="Nginx日志变量解释"></a>Nginx日志变量解释</h3><p>log_format<br>    $remote_addr             #记录访问网站的客户端地址<br>    $remote_user             #nginx认证用户名<br>    $time_local              #记录访问时间与时区<br>    $request                 #用户的http请求行, GET等方法、http协议版本<br>    $status                  #http状态码，记录请求返回的状态码，例如：200、301、404等<br>    $body_bytes_sent         #服务器发送给客户端的响应body字节数大小，默认为B(byte)<br>    $http_referer            #记录此次请求是从哪个连接访问过来的，可以根据该参数进行防盗链设置。<br>    $http_user_agent         #记录客户端访问信息，例如：浏览器、手机客户端等<br>    $http_x_forwarded_for    #当前端有代理服务器时，设置web节点记录客户端地址的配置，此参数生效的前提是代理服务器也要进行相关的x_forwarded_for设置</p>
<h2 id="1-2访问日志段分析"><a href="#1-2访问日志段分析" class="headerlink" title="1.2访问日志段分析"></a>1.2访问日志段分析</h2><p>摘出来一段部分结果：</p>
<p>120.4.15.223 - lemon [22/Jun/2020:12:01:43 +0800] “GET /index.php/archives/56/ HTTP/1.1” 200 4865 “<a target="_blank" rel="noopener" href="http://www.lemon-li.cn/&quot;">http://www.lemon-li.cn/&quot;</a> “Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:77.0) Gecko/20100101 Firefox/77.0” “-“</p>
<p>各个字段所对应的变量</p>
<p>192.168.2.254                            //$remote_addr<br>lemon                                    //$remote_user<br>[22/Jun/2020:12:01:43 +0800]             //$time_local<br>“GET /index.php/archives/56/ HTTP/1.1”   //$request<br>200                                      //$status<br>4865                                     //$body_bytes_sent<br>“<a target="_blank" rel="noopener" href="http://www.lemon-li.cn/&quot;">http://www.lemon-li.cn/&quot;</a>                //$http_referer<br>“Mozilla/5.0 (Windows xx Firefox/77.0”   //$http_user_agent<br>“-“                                      //$http_x_forwarded_for</p>
<h2 id="1-3-Nginx访问日志统计"><a href="#1-3-Nginx访问日志统计" class="headerlink" title="1.3 Nginx访问日志统计"></a>1.3 Nginx访问日志统计</h2><p>##统计tcp连接数<br>netstat -anpt|awk ‘NR&gt;=3{print $6}’|sort -rn|uniq -c</p>
<p>##统计访问日志中访问量最多的10个IP地址, 这下面两个都行<br>awk ‘{print $1}’ /usr/local/nginx/logs/access.log | sort | uniq -c | sort -nr -k1 | head -n 10<br>cat /usr/local/nginx/logs/access.log|awk ‘{a[$1]++} END {for(b in a) print b”\t”a[b]}’|sort -k2 -r|head -n 10</p>
<p>##统计HTTP状态码次数<br>awk ‘{S[$9]++};END{for(i in S) {print S[i],i}}’ /usr/local/nginx/logs/access.log|sort -nr|head</p>
<p>##注解：<br>awk ‘{ print $1}’：取数据的低1域（第1列）。<br>sort：对IP部分进行排序。<br>uniq -c：打印每一重复行出现的次数。（并去掉重复行）。<br>sort -nr -k1：按照重复行出现的次序倒序排列，-k1以第一列为标准排序。<br>head -n 10：取排在前5位的IP 。</p>
<h2 id="1-4-http-access-module局限性"><a href="#1-4-http-access-module局限性" class="headerlink" title="1.4 http_access_module局限性"></a>1.4 http_access_module局限性</h2><blockquote>
<p>下图是没有使用 http_x_forwarded_for 记录真实客户端IP地址以及代理服务器IP</p>
</blockquote>
<p>[(img)]</p>
<blockquote>
<p>下图是使用 http_x_forwarded_for 记录真实客户端IP地址以及代理服务器IP</p>
</blockquote>
<p>[(img)]</p>
<p><strong>解决方式</strong></p>
<ol>
<li><p>==采用HTTP头信息控制访问, 代理以及web服务开启 http_x_forwarded_for==</p>
</li>
<li><p>结合geo模块作</p>
</li>
<li><p>通过HTTP自动以变量传递</p>
</li>
</ol>
<h1 id="Nginx常用的基本配置"><a href="#Nginx常用的基本配置" class="headerlink" title="Nginx常用的基本配置"></a>Nginx常用的基本配置</h1><h2 id="1-1-Nginx-虚拟主机"><a href="#1-1-Nginx-虚拟主机" class="headerlink" title="1.1 Nginx 虚拟主机"></a>1.1 Nginx 虚拟主机</h2><blockquote>
<p>所谓虚拟主机，在web服务器里就是一个独立的网站 站点，这个站点对应独立的域名(也可能是IP或端口)，具有独立的程序及资源目录，可以独立地对外提供服务供用户访问。</p>
</blockquote>
<h3 id="1-1-1-配置基于域名虚拟主机（最常用的）"><a href="#1-1-1-配置基于域名虚拟主机（最常用的）" class="headerlink" title="1.1.1 配置基于域名虚拟主机（最常用的）"></a>1.1.1 配置基于域名虚拟主机（最常用的）</h3><p>1.创建web站点⽬目录<br>[root@nginx conf]# mkdir -p /soft/code/{www,bbs}<br>[root@nginx conf]# echo “www” &gt; /soft/code/www/index.html<br>[root@nginx conf]# echo “bbs” &gt; /soft/code/bbs/index.html<br>[root@nginx conf]# tree /soft/<br>/soft/<br>└── code<br>    ├── bbs<br>    │   └── index.html<br>    └── www<br>        └── index.html</p>
<p>2.配置虚拟主机<br>[root@nginx conf]# cat vhosts/{www,bbs}.conf<br>server {<br>    listen 80;<br>    server_name <a target="_blank" rel="noopener" href="http://www.lemon-li.cn/">www.lemon-li.cn</a>;<br>    root /soft/code/www;<br>    index    index.html;<br>    …<br>}<br>server {<br>    listen 80;<br>    server_name bbs.lemon-li.cn;<br>    root /soft/code/bbs;<br>    index    index.html;<br>    …<br>}</p>
<p>3.访问<br>[root@nginx conf]# curl <a target="_blank" rel="noopener" href="http://www.lemon-li.cn/">www.lemon-li.cn</a><br>www</p>
<p>[root@nginx conf]# curl bbs.lemon-li.cn<br>bbs</p>
<h3 id="1-1-2-配置不同端口访问不同虚拟主机"><a href="#1-1-2-配置不同端口访问不同虚拟主机" class="headerlink" title="1.1.2 配置不同端口访问不同虚拟主机"></a>1.1.2 配置不同端口访问不同虚拟主机</h3><p>// 仅修改 listen 监听端口即可 , 但不能和系统端口发生冲突!<br>server {<br>    …<br>    listen 8001;<br>    …<br>}</p>
<p>server {<br>    …<br>    listen 8002;<br>    …<br>}</p>
<h3 id="1-1-3-配置虚拟主机别名"><a href="#1-1-3-配置虚拟主机别名" class="headerlink" title="1.1.3 配置虚拟主机别名"></a>1.1.3 配置虚拟主机别名</h3><blockquote>
<p>所谓虚拟主机别名，就是虚拟主机设置除了主域名以外的一个域名，实现用户访问的多个域名对应同一个虚拟主机网站的功能</p>
<p>这里以bbs.lemon-li.cn域名的虚拟主机为例，为其增加一个别名lemon.com时，出现网站内容和访问bbs.lemon-li.cn是一样的</p>
<p>具体配置如下：</p>
</blockquote>
<p>// 默认配置<br>[root@nginx conf]# vim /etc/nginx/nginx.conf<br>server {<br>    listen 80;<br>    server_name bbs.lemon-li.cn;<br>    …<br>}</p>
<p>// 别名配置<br>[root@nginx conf]# vim /etc/nginx/nginx.conf<br>server {<br>    listen 80;<br>    server_name bbs.lemon-li.cn lemon-li-cn;<br>    …<br>}</p>
<p>// 使用 Linux 下 curl 测试结果<br>[root@nginx conf]# curl lemon-li.cn<br>bbs.lemon-li.cn</p>
<p>[root@nginx conf]# curl bbs.lemon-li.cn<br>bbs.lemon-li.cn</p>
<p>// 访问带 bbs 和不带 bbs 是一样的, 当然除了别名实现也可以通过 rewrite 实现</p>
<h2 id="1-2-Nginx-状态监控"><a href="#1-2-Nginx-状态监控" class="headerlink" title="1.2 Nginx 状态监控"></a>1.2 Nginx 状态监控</h2><blockquote>
<p>–with-http_stub_status_module             记录 Nginx 客户端基本访问状态信息</p>
</blockquote>
<p><strong>默认用法：</strong></p>
<p>Syntax: stub_status;<br>Default: off<br>Context: server, location</p>
<p><strong>具体配置：</strong></p>
<p>location /status {<br>    stub_status on;<br>    access_log off;<br>}</p>
<p><strong>提供了以下状态信息：</strong></p>
<p>Active connections: 1</p>
<h2 id="Nginx-当前活跃连接数-有多少人在请求"><a href="#Nginx-当前活跃连接数-有多少人在请求" class="headerlink" title="Nginx 当前活跃连接数, 有多少人在请求"></a>Nginx 当前活跃连接数, 有多少人在请求</h2><p>server accepts handled requests<br> 1 1 1</p>
<h2 id="server表示Nginx处理接收握⼿总次数。"><a href="#server表示Nginx处理接收握⼿总次数。" class="headerlink" title="server表示Nginx处理接收握⼿总次数。"></a>server表示Nginx处理接收握⼿总次数。</h2><h2 id="accepts表示Nginx处理接收总连接数。"><a href="#accepts表示Nginx处理接收总连接数。" class="headerlink" title="accepts表示Nginx处理接收总连接数。"></a>accepts表示Nginx处理接收总连接数。</h2><h2 id="请求丢失数-握⼿数-连接数-可以看出-本次状态显示没有丢失请求。"><a href="#请求丢失数-握⼿数-连接数-可以看出-本次状态显示没有丢失请求。" class="headerlink" title="请求丢失数=(握⼿数-连接数)可以看出,本次状态显示没有丢失请求。"></a>请求丢失数=(握⼿数-连接数)可以看出,本次状态显示没有丢失请求。</h2><h2 id="handled-requests，表示总共处理了了1次请求。"><a href="#handled-requests，表示总共处理了了1次请求。" class="headerlink" title="handled requests，表示总共处理了了1次请求。"></a>handled requests，表示总共处理了了1次请求。</h2><p>Reading: 0 Writing: 1 Waiting: 0</p>
<h2 id="Reading表示Nginx读取数据"><a href="#Reading表示Nginx读取数据" class="headerlink" title="Reading表示Nginx读取数据"></a>Reading表示Nginx读取数据</h2><h2 id="Writing表示Nginx写的情况"><a href="#Writing表示Nginx写的情况" class="headerlink" title="Writing表示Nginx写的情况"></a>Writing表示Nginx写的情况</h2><h2 id="Waiting表示Nginx开启keep-alive长连接情况下-既没有读也没有写-建立连接情况"><a href="#Waiting表示Nginx开启keep-alive长连接情况下-既没有读也没有写-建立连接情况" class="headerlink" title="Waiting表示Nginx开启keep-alive长连接情况下, 既没有读也没有写, 建立连接情况"></a>Waiting表示Nginx开启keep-alive长连接情况下, 既没有读也没有写, 建立连接情况</h2><p><strong>使用ab命令测试压力</strong></p>
<p>ab -c 10 -n 100 <a target="_blank" rel="noopener" href="http://192.168.2.1/index.html">http://192.168.2.1:80/index.html</a><br>-c  并发数<br>-n  总的请求数<br>-k  是否开启长连接</p>
<p><strong>访问查看</strong></p>
<p>(img)</p>
<h2 id="1-3-Nginx下载站点"><a href="#1-3-Nginx下载站点" class="headerlink" title="1.3 Nginx下载站点"></a>1.3 Nginx下载站点</h2><blockquote>
<p>Nginx默认是不允许列出整个目录浏览下载的 !</p>
</blockquote>
<p><strong>默认用法：</strong></p>
<p>Syntax: autoindex on | off;<br>Default: off;<br>Context: http, server, location</p>
<p>//autoindex常⽤用参数<br>autoindex_exact_size off;<br>默认为on， 显示出文件的确切大小，单位是bytes。<br>修改为off，显示出文件的大概大小，单位是kB或者MB或者GB。</p>
<p>autoindex_localtime on;<br>默认为off，显示的文件时间为GMT时间。<br>修改为on， 显示的文件时间为文件的服务器时间。</p>
<p>charset utf-8,gbk;<br>默认中文目录乱码，添加上解决乱码。</p>
<p><strong>具体配置：</strong></p>
<p>//开启目录浏览<br>location / {<br>    root  /download;<br>    autoindex  on;<br>    charset utf-8,gbk;<br>    autoindex_localtime on;<br>    autoindex_exact_size off;<br>}</p>
<p>//创建站点资源<br>[root@nginx /]# mkdir -p /download<br>[root@nginx /]# cd download/<br>[root@nginx download]# touch lemon{1..20}.txt</p>
<p><strong>展示效果：</strong></p>
<p>(img)</p>
<h2 id="1-4-Nginx-访问控制"><a href="#1-4-Nginx-访问控制" class="headerlink" title="1.4 Nginx 访问控制"></a>1.4 Nginx 访问控制</h2><blockquote>
<p><strong>基于IP的访问控制 http_access_module</strong></p>
<p><strong>基于⽤用户登陆认证 http_auth_basic_module</strong></p>
</blockquote>
<h3 id="1-4-1-基于IP的访问控制"><a href="#1-4-1-基于IP的访问控制" class="headerlink" title="1.4.1 基于IP的访问控制"></a>1.4.1 基于IP的访问控制</h3><p><strong>语法格式如下：</strong></p>
<p>// 允许配置语法<br>Syntax: allow address | CIDR | unix: | all;<br>Default: —<br>Context: http, server, location, limit_except</p>
<p>// 拒绝配置语法<br>Syntax: deny address | CIDR | unix: | all;<br>Default: —<br>Context: http, server, location, limit_except</p>
<p><strong>具体配置如下：</strong></p>
<p>// 配置拒绝某一个 IP, 其他全部允许<br>location /status {<br>    deny 192.168.2.254;<br>    allow all;<br>    stub_status on;<br>    access_log off;<br>}</p>
<p>// 只允许某一个网段访问 , 其它全部拒绝<br>location /status {<br>    allow 192.168.2.0/24;<br>    deny all;<br>    stub_status on;<br>    access_log off;<br>}</p>
<h3 id="1-4-2-基于用户登陆认证"><a href="#1-4-2-基于用户登陆认证" class="headerlink" title="1.4.2 基于用户登陆认证"></a>1.4.2 基于用户登陆认证</h3><p><strong>语法格式如下：</strong></p>
<p>// 配置语法<br>Syntax:  auth_basic string | off;<br>Default: auth_basic off;<br>Context: http, server, location, limit_except</p>
<p>// ⽤户密码记录配置文件<br>Syntax:  auth_basic_user_file file;<br>Default: —<br>Context: http, server, location, limit_except</p>
<p><strong>具体配置如下：</strong></p>
<p>// 需要安装依赖组件<br>[root@nginx ~]# yum install httpd-tools<br>[root@nginx ~]# htpasswd -c /usr/local/nginx/conf/user.conf lemon<br>[root@nginx ~]# cat /usr/local/nginx/conf/user.conf<br>lemon:$apr1$TLvI5fjG$vOFaI7v3AxSFD/M/NO3TP/</p>
<p>// 可在 http,server,location 里添加如下信息<br>auth_basic “Auth access Blog Input your Passwd!”;<br>auth_basic_user_file /usr/local/nginx/conf/user.conf;</p>
<h3 id="1-4-3-上面两者也可以一起用"><a href="#1-4-3-上面两者也可以一起用" class="headerlink" title="1.4.3 上面两者也可以一起用"></a>1.4.3 上面两者也可以一起用</h3><p>//想对哪个网页进行加密就在哪个里面加入以下配置：<br>auth_basic “Auth access Blog Input your Passwd!”;<br>auth_basic_user_file /usr/local/nginx/conf/user.conf;<br>allow 192.168.2.254;<br>deny all;</p>
<h2 id="1-5-Nginx-访问限制"><a href="#1-5-Nginx-访问限制" class="headerlink" title="1.5 Nginx 访问限制"></a>1.5 Nginx 访问限制</h2><h3 id="1-5-1-http协议的连接与请求"><a href="#1-5-1-http协议的连接与请求" class="headerlink" title="1.5.1 http协议的连接与请求"></a>1.5.1 http协议的连接与请求</h3><blockquote>
<p>HTTP是建立在TCP,  在完成HTTP请求需要先建立TCP三次握手（称为TCP连接），在连接的基础上在HTTP请求。</p>
</blockquote>
<p>(img)</p>
<h3 id="1-5-2-HTTP-协议的连接与请求"><a href="#1-5-2-HTTP-协议的连接与请求" class="headerlink" title="1.5.2 HTTP 协议的连接与请求"></a>1.5.2 HTTP 协议的连接与请求</h3><ul>
<li><p>HTTP 请求建立在一次 TCP 连接基础上</p>
</li>
<li><p>一次 TCP 请求至少产生一次 HTTP 请求</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>HTTP协议版本</th>
<th>连接关系</th>
</tr>
</thead>
<tbody><tr>
<td>HTTP1.0</td>
<td>TCP不能复用</td>
</tr>
<tr>
<td>HTTP1.1</td>
<td>顺序性TCP复用</td>
</tr>
<tr>
<td>HTTP2.0</td>
<td>多路复用TCP复用</td>
</tr>
</tbody></table>
<h3 id="1-5-3-Nginx-连接限制"><a href="#1-5-3-Nginx-连接限制" class="headerlink" title="1.5.3 Nginx 连接限制"></a>1.5.3 Nginx 连接限制</h3><blockquote>
<p><strong>连接频率限制  limit_conn_module</strong></p>
</blockquote>
<p><strong>连接限制语法：</strong></p>
<p>(img)</p>
<p>(img)</p>
<p><strong>具体配置如下 :</strong></p>
<p>http {<br>    //http 段配置连接限制 , 同一时刻只允许一个客户端 IP 连接<br>    limit_conn_zone $binary_remote_addr zone=conn_zone:10m;<br>    …<br>    server {<br>    …<br>        location / {<br>            // 限制向客户端返回的速度，每秒钟速率50字节，这个配置仅仅只是为了能看到效果<br>            limit_rate 50;<br>            // 同一时刻只允许一个客户端 IP 连接<br>            limit_conn conn_zone 1;<br>            // 修改限制发生时向客户端返回的错误码，可做可不做<br>            limit_conn_status 500;<br>            // 修改限制发生时的日志级别，可做可不做<br>            limit_conn_log_level warn;<br>            …<br>        }<br>    }<br>}</p>
<p><strong>打开两个终端同时请求</strong></p>
<p>curl <a target="_blank" rel="noopener" href="http://ttk.lemon-li.cn/">http://ttk.lemon-li.cn/</a></p>
<p>(img)</p>
<p>[(img)]</p>
<h3 id="1-5-4-Nginx-请求限制"><a href="#1-5-4-Nginx-请求限制" class="headerlink" title="1.5.4 Nginx 请求限制"></a>1.5.4 Nginx 请求限制</h3><blockquote>
<p>请求频率限制 limit_req_module</p>
</blockquote>
<p><strong>请求限制语法：</strong></p>
<p>(img)</p>
<p>(img)</p>
<p><strong>具体配置如下：</strong></p>
<p>http {<br>    //http 段配置请求限制, rate 限制速率，限制一秒钟最多一个 IP 请求<br>    limit_req_zone $binary_remote_addr zone=req_zone:10m rate=1r/s;<br>    …<br>    server {<br>        …<br>        location / {<br>// 1r/s 内只接收一个请求, 剩下的将被延迟处理, 请求数超过 burst 定义的数量, 多余请求拒绝处理并返回503错误码给客户端<br>            limit_req zone=req_zone burst=3 nodelay;<br>            …<br>        }<br>    }<br>}</p>
<p><strong>ab压力测试：</strong></p>
<p>ab -c 10 -n 100 <a target="_blank" rel="noopener" href="http://192.168.2.1/index.html">http://192.168.2.1:80/index.html</a></p>
<p>Benchmarking ttk.lemon-li.cn (be patient)…..done</p>
<p>Server Software:        nginx<br>Server Hostname:        ttk.lemon-li.cn<br>Server Port:            80</p>
<p>Document Path:          /<br>Document Length:        25 bytes</p>
<p>Concurrency Level:      20<br>Time taken for tests:   0.033 seconds<br>Complete requests:      50<br>Failed requests:        46         # 可以看到这里，失败了46次，也就是说50次请求只成功了4次，也就是1 + 3 = 4<br>   (Connect: 0, Receive: 0, Length: 46, Exceptions: 0)<br>Write errors:           0<br>Non-2xx responses:      46<br>Total transferred:      18062 bytes<br>HTML transferred:       9576 bytes<br>Requests per second:    1503.17 [#/sec] (mean)<br>Time per request:       13.305 [ms] (mean)<br>Time per request:       0.665 [ms] (mean, across all concurrent requests)<br>Transfer rate:          530.28 [Kbytes/sec] received</p>
<p>Connection Times (ms)<br>              min  mean[+/-sd] median   max<br>Connect:        3    4   0.6      4       5<br>Processing:     3    4   0.6      4       5<br>Waiting:        3    4   0.6      4       5<br>Total:          6    8   1.1      8      10</p>
<p>Percentage of the requests served within a certain time (ms)<br>  50%      8<br>  66%      8<br>  75%      9<br>  80%      9<br>  90%      9<br>  95%      9<br>  98%     10<br>  99%     10<br> 100%     10 (longest request)</p>
<p><strong>使用浏览器测试狂点刷新5次就会报503</strong></p>
<p>![image-20200621205106691](Nginx%E7%AC%94%E8%AE%B0.assets/GIF 2020-6-24 16-07-32.gif)</p>
<p><strong>查看错误日志信息</strong></p>
<p>2020/06/24 16:27:04 [error] 960#0: *1903 limiting requests, excess: 3.486 by zone “req_zone”, client: 101.200.227.38, server: ttk.lemon-li.cn, request: “GET / HTTP/1.0”, host: “ttk.lemon-li.cn”</p>
<h3 id="1-5-5-整体总结"><a href="#1-5-5-整体总结" class="headerlink" title="1.5.5 整体总结"></a>1.5.5 整体总结</h3><blockquote>
<p>==<strong>连接限制 没有 请求限制有效?</strong>==</p>
</blockquote>
<ul>
<li><p>前面说过, 多个请求可以建立在一次的TCP连接之上,  那么我们对请求的精度限制，当然比对一个连接的限制会更加的有效。</p>
</li>
<li><p>因为同一时刻只允许一个连接请求进入。</p>
</li>
<li><p>但是同一时刻多个请求可以通过一个连接进入。</p>
</li>
<li><p>所以请求限制才是比较合理的限制解决方案。</p>
</li>
</ul>
<h2 id="1-6-Nginx日志分割"><a href="#1-6-Nginx日志分割" class="headerlink" title="1.6 Nginx日志分割"></a>1.6 Nginx日志分割</h2><blockquote>
<p><strong>技术要点：</strong></p>
<ol>
<li><p>剪切日志后，使用 ==kill -USR1== 发送信号重新生成日志文件，同时还不影响网站请求处理进程。</p>
</li>
<li><p>错误时通过echo和tee -a命令将错误显示的同时写入到日志文件/var/log/messages。</p>
</li>
</ol>
</blockquote>
<h3 id="1-6-1-手动日志分割"><a href="#1-6-1-手动日志分割" class="headerlink" title="1.6.1 手动日志分割"></a>1.6.1 手动日志分割</h3><p>// 查看nginx日志文件<br>[root@nginx ~]# ll -h /usr/local/nginx/logs/<br>总用量 60K<br>-rw-r–r– 1 root root 52K 6月  25 00:41 access.log<br>-rw-r–r– 1 root root 478 6月  25 00:39 error.log<br>-rw-r–r– 1 root root   4 6月  25 00:33 nginx.pid</p>
<p>// 先备份日志文件<br>[root@nginx logs]# pwd<br>/usr/local/nginx/logs<br>[root@nginx logs]# cp access.log access.log.bak<br>[root@nginx logs]# ll -h<br>总用量 60K<br>-rw-r–r– 1 nginx root 52K 6月  25 00:51 access.log<br>-rw-r–r– 1 root  root 52K 6月  25 00:41 access.log.bak<br>-rw-r–r– 1 nginx root 829 6月  25 00:52 error.log<br>-rw-r–r– 1 root  root   4 6月  25 00:33 nginx.pid</p>
<p>// 手动执行日志切割命令 或 发送信号<br>[root@nginx logs]# nginx -s reopen<br>[root@nginx logs]# ll -h<br>总用量 60K<br>-rw-r–r– 1 nginx root   0 6月  25 00:51 access.log<br>-rw-r–r– 1 root  root 52K 6月  25 00:41 access.log.bak<br>-rw-r–r– 1 nginx root 829 6月  25 00:52 error.log<br>-rw-r–r– 1 root  root   4 6月  25 00:33 nginx.pid</p>
<h3 id="1-6-2-自动日志分割"><a href="#1-6-2-自动日志分割" class="headerlink" title="1.6.2 自动日志分割"></a>1.6.2 自动日志分割</h3><blockquote>
<p><strong>就是写一个脚本，然后放到计划任务当中按时间自动切割日志</strong></p>
</blockquote>
<p>// 编写日志切割脚本<br>[root@nginx ~]# vi /root/cut_nginx_log.sh<br>#!/bin/bash<br>datetime=$(date -d “-1 day” “+%Y%m%d”)<br>log_path=”/usr/local/nginx/logs”<br>pid_path=”/usr/local/nginx/logs/nginx.pid”<br>mkdir -p $log_path/backup<br>if [ -f $pid_path ];then<br>    mv $log_path/access.log $log_path/backup/access.log-$datetime<br>    kill -USR1 $(cat $pid_path)  #USR1通常被用来告知应用程序重载配置文件<br>    find $log_path/backup -mtime +30 | xargs rm -f<br>else<br>    echo “Error,Nginx is not working!”  &gt;&gt; /var/log/messages<br>fi</p>
<p>// 给予脚本执行权限<br>[root@nginx ~]# chmod +x /root/cut_nginx_log.sh</p>
<p>//添加至计划任务，每天的00:00点执行<br>[root@nginx ~]# echo “0 0 * * * /root/cut_nginx_log.sh” &gt;&gt; /var/spool/cron/root<br>[root@nginx ~]# crontab –l</p>
<p>//手动执行一下这个脚本验证下效果<br>[root@nginx ~]# bash -x /root/cut_nginx_log.sh<br>++ date -d ‘-1 day’ +%Y%m%d</p>
<ul>
<li>datetime=20200624</li>
<li>log_path=/usr/local/nginx/logs</li>
<li>pid_path=/usr/local/nginx/logs/nginx.pid</li>
<li>mkdir -p /usr/local/nginx/logs/backup</li>
<li>‘[‘ -f /usr/local/nginx/logs/nginx.pid ‘]’</li>
<li>mv /usr/local/nginx/logs/access.log /usr/local/nginx/logs/backup/access.log-20200624</li>
<li><ul>
<li>cat /usr/local/nginx/logs/nginx.pid</li>
</ul>
</li>
<li>kill -USR1 968</li>
<li>find /usr/local/nginx/logs/backup -mtime +30</li>
<li>xargs rm -f</li>
</ul>
<p>// 查看日志是否被切割及备份<br>[root@nginx ~]# ls /usr/local/nginx/logs/backup/<br>access.log-20200624</p>
<h2 id="1-7-Nginx平滑升级部署"><a href="#1-7-Nginx平滑升级部署" class="headerlink" title="1.7 Nginx平滑升级部署"></a>1.7 Nginx平滑升级部署</h2><blockquote>
<ul>
<li><strong>作用：在不影响客户端业务的情况下升级Nginx服务</strong></li>
<li>==<strong>切记，这里一定要使用绝对路径启动Nginx，才能够作热升级</strong>==</li>
</ul>
</blockquote>
<p>(img)</p>
<p><strong>Nginx信号详解：</strong></p>
<p>1.TERM，INT：nginx的主进程马上被关闭，不能完整处理正在使用的nginx的用户的请求，等同于 nginx -s stop。<br>2.QUIT：优雅的关闭nginx进程，在处理完所有正在使用nginx用户请求后再关闭nginx进程，等同于nginx -s quit。<br>3.HUP： nginx主进程不变，nginx进程不关闭，但是重新加载配置文件。等同于nginx -s reload。<br>4.USR1：不用关闭nginx进程就可以重读日志，此命令可以用于nginx的日志定时备份，按月/日等时间间隔分割有用。<br>5.USR2：nginx的版本需要升级的时候，不需要停止nginx，就能对nginx升级。<br>6.WINCH：配合USR2对nginx升级，优雅的关闭nginx旧版本的进程</p>
<p>(img)</p>
<blockquote>
<p><strong>具体操作如下：</strong></p>
<ul>
<li>当前版本为：nginx-1.12.2</li>
<li>升级版本为：nginx-1.16.1</li>
</ul>
</blockquote>
<p>// 查看旧的nginx都编译了什么模块，一会编译新版本时就照着加就行了<br>[root@nginx ~]# nginx -V<br>nginx version: nginx/1.12.2<br>built by gcc 4.8.5 20150623 (Red Hat 4.8.5-39) (GCC)<br>built with OpenSSL 1.0.2k-fips  26 Jan 2017<br>TLS SNI support enabled<br>configure arguments: –prefix=/usr/local/nginx –user=nginx –group=nginx –with-http_ssl_module –with-http_stub_status_module –with-threads –with-file-aio –with-http_sub_module –with-http_dav_module –with-http_flv_module –with-mail –with-mail_ssl_module –with-stream –with-stream_ssl_module –with-stream_realip_module</p>
<p>// 查看旧版本nginx的后台进程PID，一会升级nginx时会用到<br>[root@nginx ~]# ps -aux|grep nginx<br>root  2241  0.0  0.1  56316  1156 ?  Ss  01:53   0:00 nginx: master process /usr/local/nginx/sbin/nginx<br>nginx 2242  0.0  0.1  56700  1932 ?  S   01:53   0:00 nginx: worker process</p>
<p>// 备份旧nginx的二进制命令文件<br>[root@nginx ~]# cp -r /usr/local/nginx/sbin/nginx /usr/local/nginx/sbin/nginx.old<br>[root@nginx ~]# ll /usr/local/nginx/sbin/<br>总用量 14888<br>-rwxr-xr-x 1 nginx nginx 7621776 6月  21 21:53 nginx<br>-rwxr-xr-x 1 root  root  7621776 6月  25 02:01 nginx.old</p>
<p>// 准备nginx-1.16.1源码包<br>[root@nginx ~]# wget <a target="_blank" rel="noopener" href="http://nginx.org/download/nginx-1.16.1.tar.gz">http://nginx.org/download/nginx-1.16.1.tar.gz</a></p>
<p>// 解压、配置、编译nginx-1.16.1源码包。注：#不能加make install，如若添加，则覆盖了!<br>[root@nginx ~]# tar xf nginx-1.16.1.tar.gz  -C /usr/src/<br>[root@nginx ~]# cd /usr/src/nginx-1.16.1/<br>[root@nginx nginx-1.16.1]# ./configure –prefix=/usr/local/nginx –user=nginx –group=nginx –with-http_ssl_module –with-http_stub_status_module –with-threads –with-file-aio –with-http_sub_module –with-http_dav_module –with-http_flv_module –with-mail –with-mail_ssl_module –with-stream –with-stream_ssl_module –with-stream_realip_module &amp;&amp; make</p>
<p>// 进入编译好的objs目录中将编译好的nginx1.16.1的二进制命令文件拷贝至对应位置<br>[root@nginx nginx-1.16.1]# cd objs/ &amp;&amp; ll<br>总用量 7976<br>-rw-r–r– 1 root root   18617 6月  25 01:55 autoconf.err<br>-rw-r–r– 1 root root   56144 6月  25 01:55 Makefile<br>-rwxr-xr-x 1 root root 7961952 6月  25 01:56 nginx<br>-rw-r–r– 1 root root    5341 6月  25 01:56 nginx.8<br>-rw-r–r– 1 root root    7651 6月  25 01:55 ngx_auto_config.h<br>-rw-r–r– 1 root root     657 6月  25 01:55 ngx_auto_headers.h<br>-rw-r–r– 1 root root    9435 6月  25 01:55 ngx_modules.c<br>-rw-r–r– 1 root root   93664 6月  25 01:56 ngx_modules.o<br>drwxr-xr-x 9 root root      91 6月  25 01:55 src<br>[root@nginx objs]# cp -rf nginx /usr/local/nginx/sbin/<br>cp：是否覆盖”/usr/local/nginx/sbin/nginx”？ y<br>[root@nginx objs]# ll /usr/local/nginx/sbin/<br>总用量 15220<br>-rwxr-xr-x 1 root root 7961952 6月  25 02:04 nginx<br>-rwxr-xr-x 1 root root 7621776 6月  25 02:01 nginx.old</p>
<p>// 开始使用信号实现热升级nginx</p>
<h2 id="发送-USR2-信号，向主进程（-master）发送-USR2-信号，Nginx-会启动一个新版本的-master-进程和对应工作进程，和旧版一起处理请求。"><a href="#发送-USR2-信号，向主进程（-master）发送-USR2-信号，Nginx-会启动一个新版本的-master-进程和对应工作进程，和旧版一起处理请求。" class="headerlink" title="发送 USR2 信号，向主进程（ master）发送 USR2 信号，Nginx 会启动一个新版本的 master 进程和对应工作进程，和旧版一起处理请求。"></a>发送 USR2 信号，向主进程（ master）发送 USR2 信号，Nginx 会启动一个新版本的 master 进程和对应工作进程，和旧版一起处理请求。</h2><p>[root@nginx objs]# kill -USR2 2241<br>[root@nginx objs]# ps -aux|grep nginx<br>root  2241  0.0  0.1  56316  1340 ?  Ss  01:53   0:00 nginx: master process /usr/local/nginx/sbin/nginx<br>nginx 2242  0.0  0.1  56700  1932 ?  S   01:53   0:00 nginx: worker process     #老版本进程<br>root  5361  0.0  0.3  56348  3336 ?  S   02:07   0:00 nginx: master process /usr/local/nginx/sbin/nginx<br>nginx 5362  0.0  0.1  56744  1928 ?  S   02:07   0:00 nginx: worker process     #新版本进程</p>
<p>[root@nginx objs]# kill -WINCH 2242      # 关闭老版本进程的worker进程<br>[root@nginx objs]# ps -aux|grep nginx<br>root  2241  0.0  0.1  56316  1340 ?  Ss  01:53   0:00 nginx: master process /usr/local/nginx/sbin/nginx<br>root  5361  0.0  0.3  56348  3336 ?  S   02:07   0:00 nginx: master process /usr/local/nginx/sbin/nginx<br>nginx 5362  0.0  0.1  56744  1928 ?  S   02:07   0:00 nginx: worker process<br>nginx 5366  0.0  0.1  56700  1928 ?  S   02:10   0:00 nginx: worker process  #这是关掉老版本woker之后新生成的woker进程</p>
<p>[root@nginx objs]# kill -QUIT 2241      # 关闭老版本进程的master进程<br>[root@nginx objs]# ps -aux|grep nginx<br>root  5361  0.0  0.3  56348  3336 ?  S   02:07   0:00 nginx: master process /usr/local/nginx/sbin/nginx<br>nginx 5362  0.0  0.1  56744  1928 ?  S   02:07   0:00 nginx: worker process</p>
<p>[root@nginx objs]# nginx -V             # 至此，nginx就算是热升级成功了<br>nginx version: nginx/1.16.1<br>built by gcc 4.8.5 20150623 (Red Hat 4.8.5-39) (GCC)<br>built with OpenSSL 1.0.2k-fips  26 Jan 2017<br>TLS SNI support enabled<br>configure arguments: –prefix=/usr/local/nginx –user=nginx –group=nginx –with-http_ssl_module –with-http_stub_status_module –with-threads –with-file-aio –with-http_sub_module –with-http_dav_module –with-http_flv_module –with-mail –with-mail_ssl_module –with-stream –with-stream_ssl_module –with-stream_realip_module</p>
<h2 id="1-8-index-和-autoindex的区别"><a href="#1-8-index-和-autoindex的区别" class="headerlink" title="1.8 index 和 autoindex的区别"></a>1.8 index 和 autoindex的区别</h2><blockquote>
<p><strong>index模块</strong></p>
</blockquote>
<p>(img)</p>
<blockquote>
<p><strong>autoindex模块</strong></p>
</blockquote>
<p>(img)</p>
<p><strong>autoindex 主要有下面四个指令：</strong></p>
<p>(img)</p>
<h2 id="1-9-root-和-alias-的区别（重点）"><a href="#1-9-root-和-alias-的区别（重点）" class="headerlink" title="1.9 root 和 alias 的区别（重点）"></a>1.9 root 和 alias 的区别（重点）</h2><blockquote>
<p><strong>root属性指定的值是要加入到最终路径的，所以访问的位置变成了 root的值/locaiton的值。而我不想把访问的URI加入到路径中。所以就需要使用alias属性，其会抛弃URI，直接访问alias指定的位置</strong></p>
</blockquote>
<h3 id="1-9-1-root属性"><a href="#1-9-1-root属性" class="headerlink" title="1.9.1 root属性"></a>1.9.1 root属性</h3><blockquote>
<p><strong>结论： root属性，会把root的值（这里是yyy）加入到访问路径（locaition）之前</strong></p>
</blockquote>
<p>location xxx {<br>    root yyy<br>}</p>
<p>浏览器访问 <a target="_blank" rel="noopener" href="http://url/aaa.html%EF%BC%8C%E5%AE%9E%E9%99%85%E8%AE%BF%E9%97%AE%E7%9A%84%E6%98%AF">http://URL/aaa.html，实际访问的是</a>  <a target="_blank" rel="noopener" href="http://url/yyy/xxx/aaa.html">http://URL/yyy/xxx/aaa.html</a></p>
<p>浏览器访问 <a target="_blank" rel="noopener" href="http://url/xxx/abc.html%EF%BC%8C%E5%AE%9E%E9%99%85%E8%AE%BF%E9%97%AE%E7%9A%84%E6%98%AF">http://URL/xxx/abc.html，实际访问的是</a>  <a target="_blank" rel="noopener" href="http://url/yyy/xxx/abc.html">http://URL/yyy/xxx/abc.html</a></p>
<p>浏览器访问 <a target="_blank" rel="noopener" href="http://url/xxx/ccc/abc.html%EF%BC%8C%E5%AE%9E%E9%99%85%E8%AE%BF%E9%97%AE%E7%9A%84%E6%98%AF">http://URL/xxx/ccc/abc.html，实际访问的是</a>  <a target="_blank" rel="noopener" href="http://url/yyy/xxx/ccc/abc.html">http://URL/yyy/xxx/ccc/abc.html</a></p>
<h3 id="1-9-2-alias属性（别名）"><a href="#1-9-2-alias属性（别名）" class="headerlink" title="1.9.2 alias属性（别名）"></a>1.9.2 alias属性（别名）</h3><blockquote>
<p><strong>结论：alias属性，会把alias的值（这里是yyy）替代访问路径匹配的部分（这里是xxx）</strong></p>
</blockquote>
<p>locaiton xxx {<br>    # alias必须以 / 结束，否则无效!!!<br>    alias /yyy/;<br>}</p>
<p>浏览器访问 <a target="_blank" rel="noopener" href="http://url/xxx.html%EF%BC%8C%E5%AE%9E%E9%99%85%E8%AE%BF%E9%97%AE%E7%9A%84%E6%98%AF">http://URL/xxx.html，实际访问的是</a>  <a target="_blank" rel="noopener" href="http://url/yyy/xxx.html">http://URL/yyy/xxx.html</a></p>
<p>浏览器访问 <a target="_blank" rel="noopener" href="http://url/xxx/abc.html%EF%BC%8C%E5%AE%9E%E9%99%85%E8%AE%BF%E9%97%AE%E7%9A%84%E6%98%AF">http://URL/xxx/abc.html，实际访问的是</a>  <a target="_blank" rel="noopener" href="http://url/yyy/abc.html">http://URL/yyy/abc.html</a></p>
<p>浏览器访问 <a target="_blank" rel="noopener" href="http://url/xxx/ccc/abc.html%EF%BC%8C%E5%AE%9E%E9%99%85%E8%AE%BF%E9%97%AE%E7%9A%84%E6%98%AF">http://URL/xxx/ccc/abc.html，实际访问的是</a>  <a target="_blank" rel="noopener" href="http://url/yyy/ccc/abc.html">http://URL/yyy/ccc/abc.html</a></p>
<h2 id="1-10-定义错误页面"><a href="#1-10-定义错误页面" class="headerlink" title="1.10 定义错误页面"></a>1.10 定义错误页面</h2><blockquote>
<p><strong>模块：</strong>error_page，作用是根据客户端的访问网站的返回状态码，为其指定到特定的错误页面</p>
</blockquote>
<p>语法：</p>
<p>error_page code [ code… ] [ = | =answer-code ] uri | @named_location </p>
<p><strong>简单示例：</strong></p>
<p>// 编写错误页面<br>echo ‘client_4xx_error’ &gt; /www/test/400_error.html<br>echo ‘client_5xx_error’ &gt; /www/test/500_error.html</p>
<p>// 定义客户端错误页面<br>error_page 400 401 402 403 404 /400_error.html;<br>location /400_error.html {<br>    root /www/test;<br>}</p>
<p>// 定义服务端错误页面<br>error_page 500 501 502 503 504 /500_error.html;<br>location /500_error.html {<br>    root /www/test;<br>}</p>
<p><strong>验证一下效果</strong></p>
<p>(img)</p>
<p>[(img)]</p>
<p>(img)</p>
<h2 id="1-11-设置Nginx防盗链"><a href="#1-11-设置Nginx防盗链" class="headerlink" title="1.11 设置Nginx防盗链"></a>1.11 设置Nginx防盗链</h2><p>zhen主机配置防盗链<br>[root@zhen ~]# vi /usr/local/nginx/conf/nginx.conf<br>在server{}区域里添加以下配置：<br>        location ~* .(wma|wmv|asf|mp3|mmf|zip|rar|gif|png|swf|flv|jpeg) {<br>            valid_referers nonde blocked  <em>.zhen.com  zhen.com;<br>            if ($invalid_referer) {<br>               rewrite  ^/  <a target="_blank" rel="noopener" href="http://www.zhen.com/error.jpg">http://www.zhen.com/error.jpg</a>;<br>            }<br>        }<br>#注意：不能存在以下缓存配置：<br>     55         location  ~  .(gif|jpg|jpeg|png|bmp|ico)$   {<br>     56             expires 1d;<br>     57         }<br>wq!<br>[root@zhen html]# systemctl restart nginx<br>解释：<br>第一行： wma|wmv|asf|mp3|mmf|zip|rar|jpg|gif|png|swf|flv 表示对这些后缀的文件进行防盗链。<br>第二行：valid_referers表示被允许的URL，none表示浏览器中 referer（Referer 是 header 的一部分，当浏览器向 web 服务器发送请求时，一般会带上 Referer，告诉服务器我是从哪个页面链接过来的，服务器基此可以获得一些信息用于处理） 为空的情况，就直接在浏览器访问图片，blocked referer 不为空的情况，但是值被代理或防火墙删除了，这些值不以http://或 https://开头，</em>.zhen是匹配URL的域名。<br>第三行：if{}判断如果是来自于invalid_referer（不被允许的URL）链接，即不是来自第二行指定的URL,就强制跳转到错误页面，当然直接返回 404 （return 404）也是可以的，也可以是图片。<br>注意：防盗链测试时，不要和expires配置一起使用。</p>
<h2 id="1-12-如何在已经安装好的nginx中添加模块"><a href="#1-12-如何在已经安装好的nginx中添加模块" class="headerlink" title="1.12 如何在已经安装好的nginx中添加模块"></a>1.12 如何在已经安装好的nginx中添加模块</h2><p>// 原已经安装好的nginx，现在需要添加一个未被编译安装的模块:</p>
<p>// 查看原来编译时都带了哪些参数</p>
<h1 id="usr-local-nginx-sbin-nginx-V"><a href="#usr-local-nginx-sbin-nginx-V" class="headerlink" title="/usr/local/nginx/sbin/nginx -V"></a>/usr/local/nginx/sbin/nginx -V</h1><p>nginx version: nginx/1.12.2<br>built by gcc 4.4.7 20120313 (Red Hat 4.4.7-16) (GCC)<br>configure arguments: –prefix=/usr/local/nginx –with-http_realip_module –with-http_sub_module –with-http_gzip_static_module –with-http_stub_status_module –with-pcre</p>
<p>进入nginx源码目录</p>
<h1 id="cd-nginx-1-12-2"><a href="#cd-nginx-1-12-2" class="headerlink" title="cd nginx-1.12.2"></a>cd nginx-1.12.2</h1><p>// 添加的参数 （要加之前已经过的编译模块，不然最后只有新编译模块）</p>
<h1 id="configure-–prefix-usr-local-nginx-–with-http-realip-module-–with-http-sub-module-–with-http-gzip-static-module-–with-http-stub-status-module-–with-pcre-–with-http-ssl-module"><a href="#configure-–prefix-usr-local-nginx-–with-http-realip-module-–with-http-sub-module-–with-http-gzip-static-module-–with-http-stub-status-module-–with-pcre-–with-http-ssl-module" class="headerlink" title="./configure –prefix=/usr/local/nginx –with-http_realip_module –with-http_sub_module –with-http_gzip_static_module –with-http_stub_status_module –with-pcre –with-http_ssl_module"></a>./configure –prefix=/usr/local/nginx –with-http_realip_module –with-http_sub_module –with-http_gzip_static_module –with-http_stub_status_module –with-pcre –with-http_ssl_module</h1><p>// 编译，make完之后在objs目录下就多了个nginx，这个就是新版本的程序了。注意 {不要make install，否则就是覆盖安装}</p>
<h1 id="make"><a href="#make" class="headerlink" title="make"></a>make</h1><p>// 替换nginx二进制文件</p>
<h1 id="cp-usr-local-nginx-sbin-nginx-usr-local-nginx-sbin-nginx-bak-备份之前的nginx二进文件"><a href="#cp-usr-local-nginx-sbin-nginx-usr-local-nginx-sbin-nginx-bak-备份之前的nginx二进文件" class="headerlink" title="cp /usr/local/nginx/sbin/nginx /usr/local/nginx/sbin/nginx.bak    (备份之前的nginx二进文件)"></a>cp /usr/local/nginx/sbin/nginx /usr/local/nginx/sbin/nginx.bak    (备份之前的nginx二进文件)</h1><h1 id="cp-objs-nginx-usr-local-nginx-sbin"><a href="#cp-objs-nginx-usr-local-nginx-sbin" class="headerlink" title="cp ./objs/nginx  /usr/local/nginx/sbin/"></a>cp ./objs/nginx  /usr/local/nginx/sbin/</h1><p>// 测试新的nginx程序是否正确</p>
<h1 id="usr-local-nginx-sbin-nginx-t"><a href="#usr-local-nginx-sbin-nginx-t" class="headerlink" title="/usr/local/nginx/sbin/nginx -t"></a>/usr/local/nginx/sbin/nginx -t</h1><p>nginx: theconfiguration file /usr/local/nginx/conf/nginx.conf syntax is ok<br>nginx:configuration file /usr/local/nginx/conf/nginx.conf test issuccessful</p>
<p>// 重新加载nginx</p>
<h1 id="usr-local-nginx-sbin-nginx-s-reload"><a href="#usr-local-nginx-sbin-nginx-s-reload" class="headerlink" title="/usr/local/nginx/sbin/nginx -s reload"></a>/usr/local/nginx/sbin/nginx -s reload</h1><p>// 查看ngixn版本极其编译参数</p>
<h1 id="usr-local-nginx-sbin-nginx-V-1"><a href="#usr-local-nginx-sbin-nginx-V-1" class="headerlink" title="/usr/local/nginx/sbin/nginx -V"></a>/usr/local/nginx/sbin/nginx -V</h1><p>nginx version: nginx/1.12.2<br>built by gcc 4.4.7 20120313 (Red Hat 4.4.7-16) (GCC)<br>built with OpenSSL 1.0.1e-fips 11 Feb 2013<br>TLS SNI support enabled<br>configure arguments: –prefix=/usr/local/nginx –with-http_realip_module –with-http_sub_module –with-http_gzip_static_module –with-http_stub_status_module –with-pcre –with-http_ssl_module</p>
<h2 id="1-13-Nginx中的location指令（重点）"><a href="#1-13-Nginx中的location指令（重点）" class="headerlink" title="1.13 Nginx中的location指令（重点）"></a>1.13 Nginx中的location指令（重点）</h2><blockquote>
<p>location的作用是根据用户请求的URI来执行不同的应用，就是根据用户请求的网站URL进行匹配，匹配成功即进行相关的操作</p>
</blockquote>
<h3 id="1-13-1-安装第三方的模块"><a href="#1-13-1-安装第三方的模块" class="headerlink" title="1.13.1 安装第三方的模块"></a>1.13.1 安装第三方的模块</h3><ul>
<li><strong>下载第三方模块echo</strong></li>
</ul>
<p>[root@nginx ~]# wget <a target="_blank" rel="noopener" href="https://github.com/openresty/echo-nginx-module/archive/v0.61.tar.gz">https://github.com/openresty/echo-nginx-module/archive/v0.61.tar.gz</a></p>
<ul>
<li><strong>重新编译添加三方echo模块</strong></li>
</ul>
<p>[root@nginx ~]# nginx -V<br>nginx version: nginx/1.16.1<br>built by gcc 4.8.5 20150623 (Red Hat 4.8.5-39) (GCC)<br>built with OpenSSL 1.0.2k-fips  26 Jan 2017<br>TLS SNI support enabled<br>configure arguments: –prefix=/usr/local/nginx –user=nginx –group=nginx –with-http_ssl_module –with-http_stub_status_module –with-threads –with-file-aio –with-http_sub_module –with-http_dav_module –with-http_flv_module –with-mail –with-mail_ssl_module –with-stream –with-stream_ssl_module –with-stream_realip_module</p>
<p>[root@nginx ~]# tar -xf  v0.61.tar.gz -C /usr/src/<br>[root@nginx ~]# cd /usr/src/nginx-1.16.1/<br>[root@nginx nginx-1.16.1]# ./configure –prefix=/usr/local/nginx –user=nginx –group=nginx –with-http_ssl_module –with-http_stub_status_module –with-threads –with-file-aio –with-http_sub_module –with-http_dav_module –with-http_flv_module –with-mail –with-mail_ssl_module –with-stream –with-stream_ssl_module –with-stream_realip_module –add-module=/usr/src/echo-nginx-module-0.61/ &amp;&amp; make<br>[root@nginx nginx-1.16.1]# cp /usr/local/nginx/sbin/nginx /usr/local/nginx/sbin/nginx.old<br>[root@nginx nginx-1.16.1]# cp -rf objs/nginx /usr/local/nginx/sbin/</p>
<p>[root@nginx nginx-1.16.1]# nginx -V<br>nginx version: nginx/1.16.1<br>built by gcc 4.8.5 20150623 (Red Hat 4.8.5-39) (GCC)<br>built with OpenSSL 1.0.2k-fips  26 Jan 2017<br>TLS SNI support enabled<br>configure arguments: –prefix=/usr/local/nginx –user=nginx –group=nginx –with-http_ssl_module –with-http_stub_status_module –with-threads –with-file-aio –with-http_sub_module –with-http_dav_module –with-http_flv_module –with-mail –with-mail_ssl_module –with-stream –with-stream_ssl_module –with-stream_realip_module –add-module=/usr/src/echo-nginx-module-0.61/</p>
<h3 id="1-13-2-location语法-及-符号规则"><a href="#1-13-2-location语法-及-符号规则" class="headerlink" title="1.13.2 location语法 及 符号规则"></a>1.13.2 location语法 及 符号规则</h3><ul>
<li><strong>location语法格式：</strong></li>
</ul>
<p>Syntax: location [ = | ~ | <del>* | ^</del> ] uri { … }<br>Syntax: location @name { … }<br>Default: —<br>Context: server, location</p>
<ul>
<li><strong>location的符号：</strong></li>
</ul>
<table>
<thead>
<tr>
<th align="left">符号</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">=</td>
<td align="left">表示精确匹配</td>
</tr>
<tr>
<td align="left">^~</td>
<td align="left">表示uri以指定字符或字符串开头</td>
</tr>
<tr>
<td align="left">~</td>
<td align="left">表示区分大小写的正则匹配</td>
</tr>
<tr>
<td align="left">~*</td>
<td align="left">表示不区分大小写的正则匹配</td>
</tr>
<tr>
<td align="left">/</td>
<td align="left">通用匹配，任何请求都会匹配到</td>
</tr>
</tbody></table>
<ul>
<li><strong>注意事项：</strong></li>
</ul>
<p>有些资料上介绍location支持 不匹配 !<del>，<br>如： location !</del> ‘png’{ … }<br>这是错误的，location不支持 !~</p>
<p>如果有这样的需求，可以通过if来实现，<br>如： if ($uri !~ ‘png’) { … }</p>
<p>注意：location优先级小于if</p>
<h3 id="1-13-4-location优先级及案例"><a href="#1-13-4-location优先级及案例" class="headerlink" title="1.13.4 location优先级及案例"></a>1.13.4 location优先级及案例</h3><blockquote>
<p>总结一句话：= 符号优先级最高，/ 符号优先级最低</p>
</blockquote>
<ul>
<li><strong>规则优先级：</strong></li>
</ul>
<p>=  高于  ^~  高于  ~* 等于 ~  高于  /</p>
<ul>
<li><strong>对比 / 和 ~</strong></li>
</ul>
<p>示例1：<br>server {<br>    listen    80;<br>    server_name  location;</p>
<pre><code>location  /abc &#123;
    echo &#39;/&#39;;
&#125;

location ~ abc &#123;
    echo &#39;~&#39;;
&#125;
</code></pre>
<p>}</p>
<p>测试命令：curl <a target="_blank" rel="noopener" href="http://127.0.0.1/abc/1.html">http://127.0.0.1/abc/1.html</a><br>结果是：~</p>
<ul>
<li><strong>对比 ~ 和 ~</strong>*</li>
</ul>
<p>示例1：<br>server {<br>    listen    80;<br>    server_name  location;<br>    root  html;</p>
<pre><code>location ~ /abc &#123;
    echo &#39;~&#39;;
&#125;

location ~* /abc &#123;
    echo &#39;~*&#39;;
&#125;
</code></pre>
<p>}<br>测试命令：curl <a target="_blank" rel="noopener" href="http://127.0.0.1/abc/1.html">http://127.0.0.1/abc/1.html</a><br>结果是：~</p>
<p>示例2：把他们两个的顺序调整一下<br>server {<br>    listen    80;<br>    server_name  location;<br>    root  html;</p>
<pre><code>location ~* /abc &#123;
    echo &#39;~*&#39;;
&#125;

location ~ /abc &#123;
    echo &#39;~&#39;;
&#125;
</code></pre>
<p>}<br>测试命令：curl <a target="_blank" rel="noopener" href="http://127.0.0.1/abc/1.html">http://127.0.0.1/abc/1.html</a><br>结果是：<del>*<br>结论是：</del>和~*优先级其实是一样的，如果两个同时出现，配置文件中哪个location靠前，哪个生效。</p>
<ul>
<li><strong>对比 ^~ 和 ~</strong></li>
</ul>
<p>示例1：<br>server {<br>    listen    80;<br>    server_name  location;<br>    root  html;</p>
<pre><code>location ~ /abc &#123;
    echo &#39;~&#39;;
&#125;

location ^~ /abc &#123;
    echo &#39;^~&#39;;
&#125;
</code></pre>
<p>}</p>
<p>测试命令：curl <a target="_blank" rel="noopener" href="http://127.0.0.1/abc/1.html">http://127.0.0.1/abc/1.html</a><br>结果是：^~</p>
<ul>
<li><strong>对比 = 和 ^~</strong></li>
</ul>
<p>示例1：<br>server {<br>    listen 80;<br>    server_name location;<br>    root  html;</p>
<pre><code>location ^~ /abc.html &#123;
    echo &#39;^~&#39;;
&#125;

location = /abc.html &#123;
    echo &#39;=&#39;;
&#125;
</code></pre>
<p>}</p>
<p>测试命令：curl <a target="_blank" rel="noopener" href="http://127.0.0.1/abc.html">http://127.0.0.1/abc.html</a><br>结果是：=</p>
<h1 id="Nginx静态资源控制"><a href="#Nginx静态资源控制" class="headerlink" title="Nginx静态资源控制"></a>Nginx静态资源控制</h1><h2 id="1-静态资源类型"><a href="#1-静态资源类型" class="headerlink" title="1. 静态资源类型"></a>1. 静态资源类型</h2><blockquote>
<p>Nginx 作为静态资源 Web 服务器部署配置, 传输非常的高效, 常常用于静态资源处理,  请求,  动静分离</p>
</blockquote>
<p>(img)</p>
<blockquote>
<p>==<em><strong>非服务器动态运行 生成的文件就属于静态资源！</strong></em>==</p>
<ul>
<li><p><strong>静态资源：</strong>可以理解为前端的固定页面，这里面包含HTML、CSS、JS、图片等等，不需要查数据库也不需要程序处理，直接就能够显示的页面，如果想修改内容则必须修改页面，但是访问效率相当高。</p>
</li>
<li><p><strong>动态资源：</strong>需要程序处理或者从数据库中读数据，能够根据不同的条件在页面显示不同的数据，内容更新不需要修改页面但是访问速度不及静态页面。</p>
</li>
</ul>
</blockquote>
<table>
<thead>
<tr>
<th>类型</th>
<th>种类</th>
</tr>
</thead>
<tbody><tr>
<td>浏览器端渲染</td>
<td>HTML、CSS、JS</td>
</tr>
<tr>
<td>图片</td>
<td>JPEG、GIF、PNG</td>
</tr>
<tr>
<td>音频</td>
<td>FLV、Mp4</td>
</tr>
<tr>
<td>文件</td>
<td>TXT、任意下载文件</td>
</tr>
</tbody></table>
<h2 id="2-静态资源基本配置"><a href="#2-静态资源基本配置" class="headerlink" title="2. 静态资源基本配置"></a>2. 静态资源基本配置</h2><h3 id="2-1-文件读取高效-sendfile"><a href="#2-1-文件读取高效-sendfile" class="headerlink" title="2.1 文件读取高效 sendfile"></a>2.1 文件读取高效 sendfile</h3><p><strong>作用简介：</strong></p>
<blockquote>
<p>==sendfile可以让Nginx在传输文件时直接在磁盘和tcp socket之间传输数据；开启这个参数后可以让数据不用经过用户buffer。==如果这个参数不开启，会先在用户空间（Nginx进程空间）申请一个buffer，用read函数把数据从磁盘读到cache，再从cache读取到用户空间的buffer，再用write函数把数据从用户空间的buffer写入到内核的buffer，最后到tcp socket。</p>
</blockquote>
<p><strong>语法格式：</strong></p>
<p>Syntax: sendfile on | off;<br>Default: sendfile off;<br>Context: http, server, location, if in location</p>
<h3 id="2-2-提高网络传输效率-tcp-nopush"><a href="#2-2-提高网络传输效率-tcp-nopush" class="headerlink" title="2.2 提高网络传输效率 tcp_nopush"></a>2.2 提高网络传输效率 tcp_nopush</h3><p><strong>作用简介：</strong></p>
<blockquote>
<p>告诉nginx在一个数据包里发送所有头文件，而不一个接一个的发送。就是说数据包不会马上传送出去，等到数据包最大时，一次性的传输出去，这样有助于解决网络堵塞。</p>
</blockquote>
<p><strong>语法格式：</strong></p>
<p>Syntax: tcp_nopush on | off;<br>Default: tcp_nopush off;<br>Context: http, server, location</p>
<h3 id="2-3-与-tcp-nopush-对应的配置-tcp-nodelay"><a href="#2-3-与-tcp-nopush-对应的配置-tcp-nodelay" class="headerlink" title="2.3 与 tcp_nopush 对应的配置 tcp_nodelay"></a>2.3 与 tcp_nopush 对应的配置 tcp_nodelay</h3><p><strong>作用简介：</strong></p>
<blockquote>
<p>告诉nginx不要缓存数据，而是一段一段的发送—当需要及时发送数据时，就应该给应用设置这个属性，这样发送一小块数据信息时就不能立即得到返回值。作用: 在keepalive连接下,提高网络的传输 ‘实时性’</p>
</blockquote>
<p><strong>语法格式：</strong></p>
<p>Syntax: tcp_nodelay on | off;<br>Default: tcp_nodelay on;<br>Context: http, server, location</p>
<h3 id="2-4-注意事项"><a href="#2-4-注意事项" class="headerlink" title="2.4 注意事项"></a>2.4 注意事项</h3><ol>
<li><p>tcp_nopush配置 与 tcp_nodelay 互斥。</p>
</li>
<li><p>在nginx中tcp_nopush必须和sendfile配合使用。</p>
</li>
</ol>
<h2 id="3-静态资源文件压缩配置"><a href="#3-静态资源文件压缩配置" class="headerlink" title="3. 静态资源文件压缩配置"></a>3. 静态资源文件压缩配置</h2><blockquote>
<p>Nginx 将响应报文发送至客户端之前可以启用压缩功能，这能够有效的节约带宽，并提高响应至客户端的速度。</p>
</blockquote>
<p>(img)</p>
<h3 id="3-1-gzip-压缩配置语法"><a href="#3-1-gzip-压缩配置语法" class="headerlink" title="3.1 gzip 压缩配置语法"></a>3.1 gzip 压缩配置语法</h3><p>Syntax: gzip on | off;<br>Default: gzip off;<br>Context: http, server, location, if in location</p>
<p>作用: 数据传输时压缩</p>
<h3 id="3-2-gzip-压缩比率配置语法"><a href="#3-2-gzip-压缩比率配置语法" class="headerlink" title="3.2 gzip 压缩比率配置语法"></a>3.2 gzip 压缩比率配置语法</h3><p>Syntax: gzip_comp_level level;<br>Default: gzip_comp_level 1;<br>Context: http, server, location</p>
<p>作用: 压缩本身比较耗费服务端性能</p>
<h3 id="3-3-gzip-压缩协议版本"><a href="#3-3-gzip-压缩协议版本" class="headerlink" title="3.3 gzip 压缩协议版本"></a>3.3 gzip 压缩协议版本</h3><p>Syntax: gzip_http_version 1.0 | 1.1;<br>Default: gzip_http_version 1.1;<br>Context: http, server, location</p>
<p>作用: 压缩使用在http哪个协议, 主流版本1.1</p>
<h3 id="3-4-图片压缩案例（不建议开启图片压缩）"><a href="#3-4-图片压缩案例（不建议开启图片压缩）" class="headerlink" title="3.4 图片压缩案例（不建议开启图片压缩）"></a>3.4 图片压缩案例（不建议开启图片压缩）</h3><p>[root@lemon-min vhosts]# mkdir -p /www/images<br>[root@lemon-min vhosts]# cat ttl.lemon-li.cn.conf<br>server {<br>     listen    80;<br>     server_name  ttl.lemon-li.cn;<br>     access_log   logs/ttl_logs/access_ttl.lemon.cn.log    main;<br>     error_log    logs/ttl_logs/error_ttl.lemon.cn.log     info;<br>     location ~ .*.(gif|jpg|jpeg)$ {<br>          root /www/images;<br>         sendfile on;<br>         gzip   on;<br>         gzip_comp_level 2;<br>         gzip_http_version 1.1;<br>         gzip_types text/plain application/json application/x-javascript application/css application/xml application/xml+rss text/javascript application/x-httpd-php image/jpeg image/gif image/png;<br>     }<br>}</p>
<p>[(img)]</p>
<p>没有开启 gzip 图片压缩时</p>
<p>(img)</p>
<p>开启 gzip 图片压缩时(关于图片的压缩比率不是太过明显)</p>
<p>(img)</p>
<h3 id="3-5-文本压缩案例"><a href="#3-5-文本压缩案例" class="headerlink" title="3.5 文本压缩案例"></a>3.5 文本压缩案例</h3><p>[root@lemon-min vhosts]# mkdir -p /www/doc<br>[root@lemon-min vhosts]# for i in {1..20000};do echo “asdabnvfgf” &gt;&gt; /www/doc/test.txt ; done<br>[root@lemon-min vhosts]# ll -h /www/doc/<br>总用量 216K<br>-rw-r–r– 1 root root 215K 6月  25 23:15 test.txt<br>[root@lemon-min vhosts]# cat ttl.lemon-li.cn.conf<br>server {<br>     listen    80;<br>     server_name  ttl.lemon-li.cn;<br>     access_log   logs/ttl_logs/access_ttl.lemon.cn.log    main;<br>     error_log    logs/ttl_logs/error_ttl.lemon.cn.log     info;<br>     location ~ .*.(txt|xml)$ {<br>         root /www/doc;<br>        sendfile on;<br>        gzip   on;<br>        gzip_comp_level 2;<br>        gzip_http_version 1.1;<br>        gzip_types text/plain application/json application/x-javascript application/css application/xml application/xml+rss text/javascript application/x-httpd-php image/jpeg image/gif image/png;<br>     }<br>}</p>
<p>没有启用 gzip 文件压缩时</p>
<p>(img)</p>
<p>启用 gzip 文件压缩时（可见压缩的重要性）</p>
<p>(img)</p>
<h2 id="4-静态资源浏览器缓存"><a href="#4-静态资源浏览器缓存" class="headerlink" title="4. 静态资源浏览器缓存"></a>4. 静态资源浏览器缓存</h2><p>==<em><strong>HTTP协议定义的缓存机制 (如: Expires; Cache-control 等)</strong></em>==</p>
<blockquote>
<p><strong>1、浏览器无缓存</strong></p>
<p>浏览器请求-&gt;无缓存-&gt;请求WEB服务器-&gt;请求响应-&gt;呈现</p>
<p><strong>2、浏览器有缓存</strong></p>
<p>浏览器请求-&gt;有缓存-&gt;校验过期-&gt;是否有更新-&gt;呈现</p>
<p>校验是否过期 Expires HTTP1.0, Cache-Control(max-age) HTTP1.1</p>
<p>协议中Etag头信息校验 Etag ()</p>
<p>Last-Modified头信息校验 Last-Modified (具体时间)</p>
</blockquote>
<p><strong>1.缓存配置语法 expires</strong></p>
<p>Syntax: expires [modified] time;<br>expires epoch | max | off;<br>Default: expires off;<br>Context: http, server, location, if in location</p>
<p><strong>2.配置静态资源缓存</strong></p>
<p>location ~ .*.(js|css|html)$ {<br>    root /soft/code/js;<br>    expires 1h;<br>}</p>
<p>location ~ .*.(jpg|gif|png)$ {<br>    root /soft/code/images;<br>    expires 1d;<br>}</p>
<p><strong>3.开发代码没有正式上线时, 希望静态文件不被缓存</strong></p>
<p>//取消js css html等静态文件缓存<br>location ~ .*.(css|js|swf|json|mp4|htm|html)$ {<br>    add_header Cache-Control no-store;<br>    add_header Pragma no-cache;<br>}</p>
<h2 id="5-静态资源防盗链"><a href="#5-静态资源防盗链" class="headerlink" title="5. 静态资源防盗链"></a>5. 静态资源防盗链</h2><blockquote>
<p><strong>防盗链就是防止别人盗用服务器中的图片、文件、视频等相关资源。防盗链：是通过location + rewrite + http_refer实现的。</strong></p>
</blockquote>
<p><strong>1. 基于 http_refer 防盗链配置模块</strong></p>
<p>Syntax: valid_referers none | blocked | server_names | string …;<br>Default: —<br>Context: server, location</p>
<p><strong>2. 准备html文件</strong></p>
<html>
<head>
    <meta charset="utf-8">
    <title>pachong<title>
 </head>
    <body style="background-color:red;">
    <img src="http://192.168.69.113/test.jpg">
    </body>
</html>

<p><strong>3. 启动防盗链</strong></p>
<p>location ~* .(wma|wmv|asf|mp3|mmf|zip|rar|gif|png|swf|flv|jpeg) {<br>    valid_referers nonde blocked  *.zhen.com  zhen.com;<br>    if ($invalid_referer) {<br>        rewrite  ^/  <a target="_blank" rel="noopener" href="http://www.zhen.com/error.jpg">http://www.zhen.com/error.jpg</a>;<br>    }<br>}</p>
<p>#注意：不能存在以下缓存配置：<br>location  ~  .(gif|jpg|jpeg|png|bmp|ico)$   {<br>    expires xxx;<br>}</p>
<p><strong>4. 验证</strong></p>
<p>// 伪造协议头访问<br>[root@C-Server ~]# curl -e “<a target="_blank" rel="noopener" href="http://www.baidu.com&quot;/">http://www.baidu.com&quot;</a> -I <a target="_blank" rel="noopener" href="http://192.168.69.113/test.jpg">http://192.168.69.113/test.jpg</a><br>HTTP/1.1 403 Forbidden<br>Server: nginx/1.12.2<br>Date: Tue, 17 Apr 2018 04:55:18 GMT<br>Content-Type: text/html<br>Content-Length: 169<br>Connection: keep-alive</p>
<p>// 伪造协议头访问<br>[root@C-Server ~]# curl -e “<a target="_blank" rel="noopener" href="http://www.xuliangwei.com&quot;/">http://www.xuliangwei.com&quot;</a> -I <a target="_blank" rel="noopener" href="http://192.168.69.113/tes">http://192.168.69.113/tes</a><br>t.jpg<br>HTTP/1.1 200 OK<br>Server: nginx/1.12.2<br>Date: Tue, 17 Apr 2018 04:55:27 GMT<br>Content-Type: image/jpeg<br>Content-Length: 174315<br>Last-Modified: Wed, 29 Nov 2017 03:16:08 GMT<br>Connection: keep-alive<br>ETag: “5a1e2678-2a8eb”<br>Expires: Tue, 17 Apr 2018 16:55:27 GMT<br>Cache-Control: max-age=43200<br>Accept-Ranges: bytes</p>
<h2 id="6-静态资源跨域访问"><a href="#6-静态资源跨域访问" class="headerlink" title="6. 静态资源跨域访问"></a>6. 静态资源跨域访问</h2><h1 id="Nginx-性能优化"><a href="#Nginx-性能优化" class="headerlink" title="[Nginx 性能优化]"></a>[Nginx 性能优化]</h1><blockquote>
<p>随着访问量的不断增加，需要对 Nginx 和内核做相应的优化来满足高并发用户的访问，<br>那下面在单台 Nginx 服务器来优化相关参数。</p>
</blockquote>
<h2 id="1-ab压力测试工具"><a href="#1-ab压力测试工具" class="headerlink" title="1. ab压力测试工具"></a>1. ab压力测试工具</h2><p>安装ab工具</p>
<p>yum -y install httpd-tools</p>
<p>测试压力</p>
<p>[root@nginx ~]# ab -c 10000 -n 100000 <a target="_blank" rel="noopener" href="http://192.168.2.1/index.html">http://192.168.2.1:80/index.html</a></p>
<p>// 打开的文件太多<br>Benchmarking 192.168.2.1 (be patient)<br>socket: Too many open files (24)</p>
<p>或者出现下面socket连接错误</p>
<p>apr_socket_recv: Connection reset by peer (104)<br>Total of 98413 requests completed</p>
<p>检测一下日志</p>
<p>[root@nginx ~]# dmesg |tail -10<br>request_sock_TCP: Possible SYN flooding on port 80. Sending cookies.  Check SNMP counters.</p>
<p>访问<a target="_blank" rel="noopener" href="http://192.168.2.1/status%E6%9F%A5%E7%9C%8B%E6%9C%89%E5%A4%9A%E5%B0%91%E4%B8%AA%E8%BF%9E%E6%8E%A5%E6%88%90%E5%8A%9F%EF%BC%8C%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%88%B0%E4%B8%8B%E5%9B%BE%EF%BC%8C%E6%89%8D%E5%AE%8C%E6%88%90%E4%BA%86133%E6%AD%A4tcp%E8%BF%9E%E6%8E%A5%EF%BC%8C%E6%88%90%E5%8A%9F%E4%BA%864%E6%AC%A1%E8%AF%B7%E6%B1%82%EF%BC%81%EF%BC%81">http://192.168.2.1/status查看有多少个连接成功，可以看到下图，才完成了133此tcp连接，成功了4次请求！！</a></p>
<p>[(img)]</p>
<h2 id="2-优化思路"><a href="#2-优化思路" class="headerlink" title="2. 优化思路"></a>2. 优化思路</h2><p>每个请求都需要建立 socket 连接，那么影响并发量的因素之一：</p>
<ol>
<li>客户端不允许一次性创建过多的连接</li>
<li>服务端不允许一次性创建过多的连接 </li>
<li>每个请求都要访问一些资源，那么影响并发量的因素之一：</li>
<li>服务端不允许一个文件在同一时间点被访问 N 次，相当于一个文件在服务端打开 N 次</li>
</ol>
<p>[(img)]</p>
<p>(img)</p>
<p>(img)</p>
<p>(img)</p>
<h2 id="Nginx-conf-配置优化"><a href="#Nginx-conf-配置优化" class="headerlink" title="Nginx.conf 配置优化"></a>Nginx.conf 配置优化</h2><h1 id="nginx-进程数，建议按照-cpu-数目来指定，一般为它的倍数。"><a href="#nginx-进程数，建议按照-cpu-数目来指定，一般为它的倍数。" class="headerlink" title="nginx 进程数，建议按照 cpu 数目来指定，一般为它的倍数。"></a>nginx 进程数，建议按照 cpu 数目来指定，一般为它的倍数。</h1><p>worker_processes 4;</p>
<h1 id="为每个进程分配-cpu，下例中将-4-个进程分配到-4-个-cpu，当然可以写多个，将一个进程分配到多个-cpu"><a href="#为每个进程分配-cpu，下例中将-4-个进程分配到-4-个-cpu，当然可以写多个，将一个进程分配到多个-cpu" class="headerlink" title="为每个进程分配 cpu，下例中将 4 个进程分配到 4 个 cpu，当然可以写多个，将一个进程分配到多个 cpu"></a>为每个进程分配 cpu，下例中将 4 个进程分配到 4 个 cpu，当然可以写多个，将一个进程分配到多个 cpu</h1><p>worker_cpu_affinity 00000001 00000010 00000100 00001000;</p>
<h1 id="这个指令是指当一个-nginx-进程打开的最多文件描述符数目，理论值应该是最多打开文件数（ulimit-n）与-nginx-进程数相除，但是-nginx-分配请求并不是那么均匀，所以最好与-ulimit-n-的值保持一致。"><a href="#这个指令是指当一个-nginx-进程打开的最多文件描述符数目，理论值应该是最多打开文件数（ulimit-n）与-nginx-进程数相除，但是-nginx-分配请求并不是那么均匀，所以最好与-ulimit-n-的值保持一致。" class="headerlink" title="这个指令是指当一个 nginx 进程打开的最多文件描述符数目，理论值应该是最多打开文件数（ulimit -n）与 nginx 进程数相除，但是 nginx 分配请求并不是那么均匀，所以最好与 ulimit -n 的值保持一致。"></a>这个指令是指当一个 nginx 进程打开的最多文件描述符数目，理论值应该是最多打开文件数（ulimit -n）与 nginx 进程数相除，但是 nginx 分配请求并不是那么均匀，所以最好与 ulimit -n 的值保持一致。</h1><p>worker_rlimit_nofile 102400;</p>
<h1 id="使用-epoll-的-I-O-模型。epoll-是-Linux-内核为处理大批量文件描述符而作了改进的poll，它能显著提高程序在大量并发连接中只有少量活跃的情况下的系统-CPU-利用率。"><a href="#使用-epoll-的-I-O-模型。epoll-是-Linux-内核为处理大批量文件描述符而作了改进的poll，它能显著提高程序在大量并发连接中只有少量活跃的情况下的系统-CPU-利用率。" class="headerlink" title="使用 epoll 的 I/O 模型。epoll 是 Linux 内核为处理大批量文件描述符而作了改进的poll，它能显著提高程序在大量并发连接中只有少量活跃的情况下的系统 CPU 利用率。"></a>使用 epoll 的 I/O 模型。epoll 是 Linux 内核为处理大批量文件描述符而作了改进的poll，它能显著提高程序在大量并发连接中只有少量活跃的情况下的系统 CPU 利用率。</h1><p>use epoll;</p>
<h1 id="每个进程的最大连接数，每台-nginx-服务器的最大连接数为worker-processes-worker-connections。"><a href="#每个进程的最大连接数，每台-nginx-服务器的最大连接数为worker-processes-worker-connections。" class="headerlink" title="每个进程的最大连接数，每台 nginx 服务器的最大连接数为worker_processes*worker_connections。"></a>每个进程的最大连接数，每台 nginx 服务器的最大连接数为worker_processes*worker_connections。</h1><p>worker_connections 102400;</p>
<h1 id="keepalive-超时时间，客户端到服务器端的连接持续有效时间-当出现对服务器的后继请求时-keepalive-timeout-功能可避免建立或重新建立连接。"><a href="#keepalive-超时时间，客户端到服务器端的连接持续有效时间-当出现对服务器的后继请求时-keepalive-timeout-功能可避免建立或重新建立连接。" class="headerlink" title="keepalive 超时时间，客户端到服务器端的连接持续有效时间,当出现对服务器的后继请求时,keepalive-timeout 功能可避免建立或重新建立连接。"></a>keepalive 超时时间，客户端到服务器端的连接持续有效时间,当出现对服务器的后继请求时,keepalive-timeout 功能可避免建立或重新建立连接。</h1><p>keepalive_timeout 60;</p>
<h1 id="客户端请求头部的缓冲区大小，这个可以根据你的系统分页大小来设置，一般一个请求的头部大小不会超过-1k，不过由于一般系统分页都要大于-1k，所以这里设置为分页大小。分页大小可以用命令-getconf-PAGESIZE-取得。"><a href="#客户端请求头部的缓冲区大小，这个可以根据你的系统分页大小来设置，一般一个请求的头部大小不会超过-1k，不过由于一般系统分页都要大于-1k，所以这里设置为分页大小。分页大小可以用命令-getconf-PAGESIZE-取得。" class="headerlink" title="客户端请求头部的缓冲区大小，这个可以根据你的系统分页大小来设置，一般一个请求的头部大小不会超过 1k，不过由于一般系统分页都要大于 1k，所以这里设置为分页大小。分页大小可以用命令 getconf PAGESIZE 取得。"></a>客户端请求头部的缓冲区大小，这个可以根据你的系统分页大小来设置，一般一个请求的头部大小不会超过 1k，不过由于一般系统分页都要大于 1k，所以这里设置为分页大小。分页大小可以用命令 getconf PAGESIZE 取得。</h1><p>client_header_buffer_size 4k;</p>
<p>这个将为打开文件指定缓存，默认是没有启用的，max 指定缓存数量，建议和打开文件数一致，inactive 是指经过多长时间文件没被请求后删除缓存。<br>open_file_cache max=102400 inactive=20s;</p>
<p>这个是指多长时间检查一次缓存的有效信息。<br>open_file_cache_valid 30s;</p>
<h1 id="open-file-cache-指令中的-inactive-参数时间内文件的最少使用次数，如果超过这个数字，文件描述符一直是在缓存中打开的，如上例，如果有一个文件在-inactive时间内一次没被使用，它将被移除。"><a href="#open-file-cache-指令中的-inactive-参数时间内文件的最少使用次数，如果超过这个数字，文件描述符一直是在缓存中打开的，如上例，如果有一个文件在-inactive时间内一次没被使用，它将被移除。" class="headerlink" title="open_file_cache 指令中的 inactive 参数时间内文件的最少使用次数，如果超过这个数字，文件描述符一直是在缓存中打开的，如上例，如果有一个文件在 inactive时间内一次没被使用，它将被移除。"></a>open_file_cache 指令中的 inactive 参数时间内文件的最少使用次数，如果超过这个数字，文件描述符一直是在缓存中打开的，如上例，如果有一个文件在 inactive时间内一次没被使用，它将被移除。</h1><p>open_file_cache_min_uses 1;</p>
<h2 id="Linux-内核参数优化"><a href="#Linux-内核参数优化" class="headerlink" title="Linux 内核参数优化"></a>Linux 内核参数优化</h2><h1 id="开启-SYN-Cookies，当出现-SYN-等待队列溢出时，启用-cookies-来处理。"><a href="#开启-SYN-Cookies，当出现-SYN-等待队列溢出时，启用-cookies-来处理。" class="headerlink" title="开启 SYN Cookies，当出现 SYN 等待队列溢出时，启用 cookies 来处理。"></a>开启 SYN Cookies，当出现 SYN 等待队列溢出时，启用 cookies 来处理。</h1><p>net.ipv4.tcp_syncookies = 1</p>
<h1 id="开启重用。允许将-TIME-WAIT-sockets-重新用于新的-TCP-连接。"><a href="#开启重用。允许将-TIME-WAIT-sockets-重新用于新的-TCP-连接。" class="headerlink" title="开启重用。允许将 TIME-WAIT sockets 重新用于新的 TCP 连接。"></a>开启重用。允许将 TIME-WAIT sockets 重新用于新的 TCP 连接。</h1><p>net.ipv4.tcp_tw_reuse = 1</p>
<h1 id="timewait-的数量，默认是-180000。"><a href="#timewait-的数量，默认是-180000。" class="headerlink" title="timewait 的数量，默认是 180000。"></a>timewait 的数量，默认是 180000。</h1><p>net.ipv4.tcp_max_tw_buckets = 10000</p>
<h1 id="启用-timewait-快速回收。"><a href="#启用-timewait-快速回收。" class="headerlink" title="启用 timewait 快速回收。"></a>启用 timewait 快速回收。</h1><p>net.ipv4.tcp_tw_recycle = 1</p>
<h1 id="允许系统打开的端口范围。"><a href="#允许系统打开的端口范围。" class="headerlink" title="允许系统打开的端口范围。"></a>允许系统打开的端口范围。</h1><p>net.ipv4.ip_local_port_range = 1024 65000</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/10/25/Nginx/" data-id="ckpjvyk850005xwg055t43uqa" data-title="Nginx" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/web/" rel="tag">web</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2021/06/05/hello-world/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          Hello World
        
      </div>
    </a>
  
  
    <a href="/2020/10/18/Jenkins/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Jenkins</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/DevOps/" rel="tag">DevOps</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/db/" rel="tag">db</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/k8s/" rel="tag">k8s</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/web/" rel="tag">web</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/DevOps/" style="font-size: 10px;">DevOps</a> <a href="/tags/db/" style="font-size: 10px;">db</a> <a href="/tags/k8s/" style="font-size: 10px;">k8s</a> <a href="/tags/web/" style="font-size: 10px;">web</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/06/">June 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">October 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/06/05/hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/2020/10/25/Nginx/">Nginx</a>
          </li>
        
          <li>
            <a href="/2020/10/18/Jenkins/">Jenkins</a>
          </li>
        
          <li>
            <a href="/2020/10/18/MySQL/">MySQL</a>
          </li>
        
          <li>
            <a href="/2020/10/07/Kubernetes/">kubernetes</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>